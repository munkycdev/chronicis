@using Chronicis.Client.Components.Shared
@using Chronicis.Client.Components.Characters
@using Chronicis.Client.Utilities
@using Chronicis.Shared.DTOs
@using Chronicis.Shared.Enums
@using Chronicis.Shared.Utilities
@using Blazored.LocalStorage
@using Microsoft.JSInterop
@inject IArticleApiService ArticleApi
@inject ILinkApiService LinkApiService
@inject IExternalLinkApiService ExternalLinkApiService
@inject IWikiLinkService WikiLinkService
@inject IAISummaryApiService SummaryApi
@inject IMarkdownService MarkdownService
@inject ITreeStateService TreeState
@inject IAppContextService AppContext
@inject IBreadcrumbService BreadcrumbService
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@inject ILocalStorageService LocalStorage
@inject ILogger<ArticleDetail> Logger
@inject IArticleCacheService ArticleCache
@inject IMetadataDrawerService MetadataDrawerService
@inject IKeyboardShortcutService KeyboardShortcutService

@implements IDisposable

@if (_isLoading)
{
    <LoadingSkeleton />
}
else if (_article == null)
{
    <EmptyState 
        Icon="üìù"
        Title="No Article Selected"
        Message="Select an article from the tree to view and edit its content."
        ActionText="Create New Article"
        OnActionClick="CreateRootArticle" />
}
else
{
    <style>
        .mud-input.mud-input-underline:before,
        .mud-input.mud-input-underline:after,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):before,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):after {
            border-bottom: none !important;        
        }

        .mud-input,
        .chronicis-editor-content {
            border: solid 1px #c7c7c4;
            border-radius: 4px;
        }

        .chronicis-article-title .mud-input {
            padding-left:8px;
        }
    </style>

    <MudPaper Elevation="2" Class="chronicis-article-card chronicis-fade-in">

        <!-- Article Header (Breadcrumbs, Icon, Title, Divider) -->
        <ArticleHeader Breadcrumbs="_breadcrumbs"
                       @bind-Title="_editTitle"
                       IconEmoji="@_article.IconEmoji"
                       OnIconChanged="HandleIconChanged"
                       OnTitleEdited="HandleTitleEdited"
                       OnEnterPressed="SaveArticle"
                       OnMetadataToggle="ToggleMetadata"
                       ShouldFocusTitle="_shouldFocusTitle"
                       ShouldFocusTitleChanged="HandleFocusTitleChanged" />

        @* Character Claim Button - only show for Character type articles *@
        @if (_article.Type == ArticleType.Character)
        {
            <div class="mb-3">
                <CharacterClaimButton CharacterId="@_article.Id" />
            </div>
        }

        <!-- TipTap Editor Container -->
        <div id="tiptap-editor-@_article.Id" class="chronicis-editor-container mb-4"></div>

        <!-- AI Summary Section -->
        <AISummarySection EntityId="@_article.Id"
                          EntityType="Article"
                          IsExpanded="@_isSummaryExpanded"
                          IsExpandedChanged="@((expanded) => _isSummaryExpanded = expanded)" />

        <!-- Action Bar (Save Status + Buttons) -->
        <ArticleActionBar IsSaving="_isSaving"
                          IsAutoLinking="_isAutoLinking"
                          IsCreatingChild="_isCreatingChild"
                          HasUnsavedChanges="_hasUnsavedChanges"
                          LastSaveTime="@_lastSaveTime"
                          OnSave="SaveArticle"
                          OnDelete="DeleteArticle"
                          OnAutoLink="AutoLinkArticle"
                          OnCreateChild="CreateChildArticle" />
    </MudPaper>

    <!-- Metadata Drawer -->
    <ArticleMetadataDrawer @ref="_metadataDrawer"
                           Article="_article"
                           @bind-IsOpen="_openMetadata" />

    <!-- External Link Preview Drawer -->
    <MudDrawer @bind-Open="_externalPreviewOpen"
               Anchor="Anchor.End"
               Variant="@DrawerVariant.Temporary"
               Elevation="9999"
               Class="external-link-preview-drawer">
        <MudDrawerHeader>
            <MudSpacer />
            <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="CloseExternalPreview" />
            
        </MudDrawerHeader>
        <MudDrawerContainer>
            <div class="external-link-preview-header">
                @if (!string.IsNullOrWhiteSpace(_externalPreviewSource))
                {
                    <span class="external-link-preview-source">@_externalPreviewSource.ToUpperInvariant()</span>
                }
                <MudText Typo="Typo.h6">@(_externalPreviewTitle ?? "External Link")</MudText>
            </div>
            @if (!string.IsNullOrWhiteSpace(_externalPreviewContent?.Kind))
            {
                <MudText Typo="Typo.caption" Style="color: var(--mud-palette-text-secondary);">
                    @_externalPreviewContent.Kind
                </MudText>
            }
            @if (_externalPreviewLoading)
            {
                <div class="d-flex justify-center align-center" style="padding: 24px;">
                    <MudProgressCircular Indeterminate="true" />
                </div>
            }
            else if (!string.IsNullOrWhiteSpace(_externalPreviewError))
            {
                <MudAlert Severity="Severity.Error">@_externalPreviewError</MudAlert>
            }
            else if (_externalPreviewContent != null)
            {
                <div class="external-link-preview-body chronicis-scrollbar-light">
                    @((MarkupString)MarkdownService.ToHtml(_externalPreviewContent.Markdown))
                </div>

                @if (!string.IsNullOrWhiteSpace(_externalPreviewContent.Attribution))
                {
                    <MudText Typo="Typo.caption" Style="color: var(--mud-palette-text-secondary); margin-top: 8px;">
                        @_externalPreviewContent.Attribution
                    </MudText>
                }

            }
        </MudDrawerContainer>
    </MudDrawer>

    <!-- Wiki Link Autocomplete -->
    @if (_showAutocomplete && _article != null)
    {
        <WikiLinkAutocomplete Suggestions="@_autocompleteSuggestions"
                              Loading="@_autocompleteLoading"
                              SelectedIndex="@_autocompleteSelectedIndex"
                              SelectedIndexChanged="OnAutocompleteIndexChanged"
                              OnSelect="OnAutocompleteSelect"
                              OnCreate="OnAutocompleteCreate"
                              Position="@_autocompletePosition"
                              Query="@_autocompleteQuery"
                              IsExternalQuery="@_autocompleteIsExternalQuery" />
    }
}

@code {
    // Article state
    private ArticleDto? _article;
    private List<BreadcrumbItem>? _breadcrumbs;
    private string _editTitle = string.Empty;
    private string _editBody = string.Empty;
    
    // UI state
    private bool _isLoading = false;
    private bool _isSaving = false;
    private bool _isAutoLinking = false;
    private bool _isCreatingChild = false;
    private bool _hasUnsavedChanges = false;
    private bool _editorInitialized = false;
    private string _lastSaveTime = "just now";
    private bool _openMetadata = false;
    private bool _isSummaryExpanded = false;
    private bool _shouldFocusTitle = false;
    
    // Timer and references
    private Timer? _autoSaveTimer;
    private DotNetObjectReference<ArticleDetail>? _dotNetHelper;
    private ArticleMetadataDrawer? _metadataDrawer;
    private bool _disposed = false;
    
    // Autocomplete state
    private bool _showAutocomplete = false;
    private bool _autocompleteLoading = false;
    private List<WikiLinkAutocompleteItem> _autocompleteSuggestions = new();
    private int _autocompleteSelectedIndex = 0;
    private (double X, double Y) _autocompletePosition = (0, 0);
    private string _autocompleteQuery = string.Empty;
    private bool _autocompleteIsExternalQuery = false;
    private string? _autocompleteExternalSourceKey;

    // External link preview
    private bool _externalPreviewOpen = false;
    private bool _externalPreviewLoading = false;
    private string? _externalPreviewError;
    private ExternalLinkContentDto? _externalPreviewContent;
    private string? _externalPreviewSource;
    private string? _externalPreviewId;
    private string? _externalPreviewTitle;
    private readonly Dictionary<string, ExternalLinkContentDto> _externalLinkCache = new(StringComparer.OrdinalIgnoreCase);
    
    private const string LastArticlePathKey = "chronicis_last_article_path";

    #region Lifecycle

    protected override async Task OnInitializedAsync()
    {
        TreeState.OnStateChanged += OnTreeStateChanged;
        MetadataDrawerService.OnToggle += OnMetadataDrawerToggle;
        KeyboardShortcutService.OnSaveRequested += HandleSaveShortcut;
        _dotNetHelper = DotNetObjectReference.Create(this);
        await Task.CompletedTask;
    }

    protected override void OnInitialized()
    {
        OnCtrlNPressed += HandleCtrlNInstance;
        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && TreeState.SelectedArticleId.HasValue)
        {
            await LoadArticleAsync(TreeState.SelectedArticleId.Value);
            StateHasChanged();
            await Task.Delay(100);
            await InitializeEditor();
        }
    }

    public void Dispose()
    {
        _disposed = true;
        TreeState.OnStateChanged -= OnTreeStateChanged;
        MetadataDrawerService.OnToggle -= OnMetadataDrawerToggle;
        KeyboardShortcutService.OnSaveRequested -= HandleSaveShortcut;
        OnCtrlNPressed -= HandleCtrlNInstance;
        _autoSaveTimer?.Dispose();
        
        // Clear and dispose the DotNetObjectReference
        var helper = _dotNetHelper;
        _dotNetHelper = null;
        helper?.Dispose();
    }

    #endregion

    #region Header Event Handlers

    private void HandleTitleEdited() => _hasUnsavedChanges = true;

    private async Task HandleIconChanged(string? newIcon)
    {
        if (_article == null || _isSaving) return;

        _article.IconEmoji = newIcon;
        _isSaving = true;
        StateHasChanged();

        try
        {
            var updateDto = new ArticleUpdateDto
            {
                Title = _editTitle?.Trim() ?? string.Empty,
                Body = _editBody,
                EffectiveDate = _article.EffectiveDate,
                IconEmoji = newIcon
            };

            await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);
            _article.ModifiedAt = DateTime.Now;
            _lastSaveTime = "just now";

            await TreeState.RefreshAsync();
            TreeState.UpdateNodeDisplay(_article.Id, _editTitle ?? string.Empty, newIcon);

            Snackbar.Add($"Icon {(string.IsNullOrEmpty(newIcon) ? "removed" : "updated")}", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save icon: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }

    private void HandleFocusTitleChanged(bool value) => _shouldFocusTitle = value;

    private void ToggleMetadata() => _openMetadata = !_openMetadata;

    #endregion

    #region Article Loading

    private async void OnTreeStateChanged()
    {
        if (_disposed) return;
        
        await InvokeAsync(async () =>
        {
            if (_disposed) return;
            
            try
            {
                if (_editorInitialized && _article != null)
                {
                    await JSRuntime.InvokeVoidAsync("destroyTipTapEditor", $"tiptap-editor-{_article.Id}");
                }

                _editorInitialized = false;

                if (_disposed) return;

                if (TreeState.SelectedArticleId.HasValue && TreeState.SelectedArticleId.Value != Guid.Empty)
                {
                    await LoadArticleAsync(TreeState.SelectedArticleId.Value);
                }
                else
                {
                    _article = null;
                    if (!_disposed)
                    {
                        await JSRuntime.InvokeVoidAsync("eval", "document.title = 'Chronicis'");
                    }
                }

                if (_disposed) return;
                StateHasChanged();

                if (_article != null && !_disposed)
                {
                    await Task.Delay(100);
                    if (!_disposed)
                    {
                        await InitializeEditor();
                    }
                }
            }
            catch (ObjectDisposedException)
            {
                // Component was disposed during async operation - this is expected during navigation
            }
            catch (JSDisconnectedException)
            {
                // JS runtime disconnected - this is expected during navigation
            }
        });
    }

    private async Task LoadArticleAsync(Guid articleId)
    {
        _isLoading = true;
        _externalPreviewOpen = false;
        StateHasChanged();

        try
        {
            _article = await ArticleApi.GetArticleAsync(articleId);
            _editTitle = _article?.Title ?? string.Empty;
            _editBody = _article?.Body ?? string.Empty;
            _hasUnsavedChanges = false;

            if (_article != null)
            {
                ArticleCache.CacheArticle(_article);
            }

            LoadBreadcrumbs();
            await UpdatePageTitle();
            await SaveLastArticlePath();

            if (string.IsNullOrEmpty(_editTitle) || TreeState.ShouldFocusTitle)
            {
                _shouldFocusTitle = true;
                TreeState.ShouldFocusTitle = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load article: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void LoadBreadcrumbs()
    {
        if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
        {
            _breadcrumbs = BreadcrumbService.ForArticle(_article.Breadcrumbs);
        }
        else
        {
            _breadcrumbs = new List<BreadcrumbItem> { new("Dashboard", href: "/dashboard") };
        }
    }

    private async Task UpdatePageTitle()
    {
        var pageTitle = string.IsNullOrEmpty(_article?.Title) ? "Untitled - Chronicis" : $"{_article.Title} - Chronicis";
        await JSRuntime.InvokeVoidAsync("eval", $"document.title = '{JsUtilities.EscapeForJs(pageTitle)}'");
    }

    private async Task SaveLastArticlePath()
    {
        if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
        {
            var path = BreadcrumbService.BuildArticleUrl(_article.Breadcrumbs);
            await LocalStorage.SetItemAsStringAsync(LastArticlePathKey, path);
        }
    }

    #endregion

    #region Editor

    private async Task InitializeEditor()
    {
        if (_article != null && !_editorInitialized && !_disposed && _dotNetHelper != null)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("initializeTipTapEditor", $"tiptap-editor-{_article.Id}", _editBody, _dotNetHelper);
                
                if (_disposed) return;
                
                await JSRuntime.InvokeVoidAsync("initializeWikiLinkAutocomplete", $"tiptap-editor-{_article.Id}", _dotNetHelper);
                _editorInitialized = true;
            }
            catch (ObjectDisposedException)
            {
                // Component was disposed during async operation - this is expected during navigation
            }
            catch (JSDisconnectedException)
            {
                // JS runtime disconnected - this is expected during navigation
            }
            catch (Exception ex)
            {
                if (!_disposed)
                {
                    Snackbar.Add($"Failed to initialize editor: {ex.Message}", Severity.Warning);
                }
            }
        }
    }

    [JSInvokable]
    public void OnEditorUpdate(string markdown)
    {
        _editBody = markdown;
        _hasUnsavedChanges = true;
        _autoSaveTimer?.Dispose();
        _autoSaveTimer = new Timer(async _ => await AutoSave(), null, 500, Timeout.Infinite);
    }

    private async Task AutoSave()
    {
        await InvokeAsync(async () =>
        {
            if (_hasUnsavedChanges && !_isSaving)
                await SaveArticle();
        });
    }

    #endregion

    #region Save & Delete

    private async Task SaveArticle()
    {
        if (_article == null || _isSaving) return;

        _isSaving = true;
        StateHasChanged();

        try
        {
            var originalTitle = _article.Title;
            var newTitle = _editTitle?.Trim() ?? string.Empty;
            var titleChanged = originalTitle != newTitle;
            string? newSlug = null;
            
            if (titleChanged)
            {
                var suggestedSlug = SlugGenerator.GenerateSlug(newTitle);
                if (suggestedSlug != _article.Slug)
                    newSlug = suggestedSlug;
            }

            var updateDto = new ArticleUpdateDto
            {
                Title = newTitle,
                Slug = newSlug,
                Body = _editBody,
                EffectiveDate = _article.EffectiveDate,
                IconEmoji = _article.IconEmoji
            };

            await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);
            ArticleCache.InvalidateCache();

            _article.Title = newTitle;
            _article.Body = _editBody;
            _article.ModifiedAt = DateTime.Now;
            _hasUnsavedChanges = false;
            _lastSaveTime = "just now";

            if (newSlug != null || titleChanged)
            {
                await UpdatePageTitle();
                TreeState.UpdateNodeDisplay(_article.Id, newTitle, _article.IconEmoji);
            }

            if (newSlug != null)
            {
                TreeState.ExpandPathToAndSelect(_article.Id);
                _article = await ArticleApi.GetArticleAsync(_article.Id);
                
                if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
                {
                    var path = BreadcrumbService.BuildArticleUrl(_article.Breadcrumbs);
                    Navigation.NavigateTo(path, replace: true);
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
            // Only refresh panels if the metadata drawer is open
            if (_metadataDrawer != null && _openMetadata)
                await _metadataDrawer.RefreshPanelsAsync();
        }
    }

    private async Task DeleteArticle()
    {
        if (_article == null) return;

        var message = $"Are you sure you want to delete '{_article.Title}'?";
        if (_article.ChildCount > 0)
        {
            var childText = _article.ChildCount == 1 ? "1 child article" : $"{_article.ChildCount} child articles";
            message = $"Are you sure you want to delete '{_article.Title}'?\n\n‚ö†Ô∏è WARNING: This will also delete {childText} and all their descendants.";
        }
        message += "\n\nThis action cannot be undone.";

        if (!await JSRuntime.InvokeAsync<bool>("confirm", message)) return;

        try
        {
            var success = await ArticleApi.DeleteArticleAsync(_article.Id);
            if (success)
            {
                ArticleCache.InvalidateCache();
                Snackbar.Add("Article deleted successfully", Severity.Success);
                await TreeState.RefreshAsync();
                _article = null;
            }
            else
            {
                Snackbar.Add("Failed to delete article. You may not have permission.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    private async Task AutoLinkArticle()
    {
        if (_article == null || _isAutoLinking) return;

        _isAutoLinking = true;
        StateHasChanged();

        try
        {
            var result = await LinkApiService.AutoLinkAsync(_article.Id, _editBody);

            if (result == null)
            {
                Snackbar.Add("Failed to scan for links", Severity.Error);
                return;
            }

            if (result.LinksFound == 0)
            {
                Snackbar.Add("No linkable content found", Severity.Info);
                return;
            }

            var matchList = string.Join("\n", result.Matches.Select(m => $"‚Ä¢ \"{m.MatchedText}\" ‚Üí {m.ArticleTitle}"));
            if (!await JSRuntime.InvokeAsync<bool>("confirm", $"Found {result.LinksFound} potential link(s):\n\n{matchList}\n\nApply these links?"))
                return;

            // Convert matches to JS-friendly format and insert via TipTap
            // For alias matches, format as "Alias ‚Üí Title", otherwise just use matched text
            var jsMatches = result.Matches.Select(m => new
            {
                articleId = m.ArticleId.ToString(),
                displayText = m.IsAliasMatch ? $"{m.MatchedText} ‚Üí {m.ArticleTitle}" : m.MatchedText,
                startIndex = m.StartIndex,
                endIndex = m.EndIndex
            }).ToArray();

            await JSRuntime.InvokeVoidAsync("insertWikiLinksAtPositions", $"tiptap-editor-{_article.Id}", jsMatches);
            
            // Get the updated content from the editor
            _editBody = await JSRuntime.InvokeAsync<string>("getTipTapContent", $"tiptap-editor-{_article.Id}");
            _hasUnsavedChanges = true;
            await SaveArticle();
            Snackbar.Add($"Added {result.LinksFound} link(s)", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error auto-linking article {ArticleId}", _article.Id);
            Snackbar.Add($"Failed to auto-link: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isAutoLinking = false;
            StateHasChanged();
        }
    }

    #endregion

    #region Article Creation

    private async Task CreateRootArticle()
    {
        var worldId = AppContext.CurrentWorldId;
        if (!worldId.HasValue || worldId == Guid.Empty)
        {
            Snackbar.Add("Please select a World first", Severity.Warning);
            return;
        }

        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = "Untitled",
                Body = string.Empty,
                ParentId = null,
                EffectiveDate = DateTime.Now,
                WorldId = worldId.Value
            };

            await ArticleApi.CreateArticleAsync(createDto);
            await TreeState.RefreshAsync();
            Snackbar.Add("Article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateSiblingArticle()
    {
        if (_article == null) return;

        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = string.Empty,
                Body = string.Empty,
                ParentId = _article.ParentId,
                EffectiveDate = DateTime.Now,
                WorldId = _article.WorldId,
                CampaignId = _article.CampaignId
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            if (created == null)
            {
                Snackbar.Add("Failed to create article", Severity.Error);
                return;
            }
            
            await TreeState.RefreshAsync();
            TreeState.ExpandPathToAndSelect(created.Id);
            
            // Fetch the full article to get breadcrumbs for navigation
            var articleDetail = await ArticleApi.GetArticleDetailAsync(created.Id);
            if (articleDetail != null && articleDetail.Breadcrumbs.Any())
            {
                var path = BreadcrumbService.BuildArticleUrl(articleDetail.Breadcrumbs);
                Navigation.NavigateTo(path);
            }
            else
            {
                // Fallback to slug-only path
                Navigation.NavigateTo($"/article/{created.Slug}");
            }
            
            Snackbar.Add("New article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateChildArticle()
    {
        if (_article == null || _isCreatingChild) return;

        _isCreatingChild = true;
        StateHasChanged();

        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = string.Empty,
                Body = string.Empty,
                ParentId = _article.Id, // Current article becomes the parent
                EffectiveDate = DateTime.Now,
                WorldId = _article.WorldId,
                CampaignId = _article.CampaignId
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            if (created == null)
            {
                Snackbar.Add("Failed to create child article", Severity.Error);
                return;
            }
            
            await TreeState.RefreshAsync();
            TreeState.ExpandPathToAndSelect(created.Id);
            TreeState.ShouldFocusTitle = true;
            
            // Fetch the full article to get breadcrumbs for navigation
            var articleDetail = await ArticleApi.GetArticleDetailAsync(created.Id);
            if (articleDetail != null && articleDetail.Breadcrumbs.Any())
            {
                var path = BreadcrumbService.BuildArticleUrl(articleDetail.Breadcrumbs);
                Navigation.NavigateTo(path);
            }
            else
            {
                // Fallback to slug-only path
                Navigation.NavigateTo($"/article/{created.Slug}");
            }
            
            Snackbar.Add("Child article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating child article under {ParentId}", _article.Id);
            Snackbar.Add($"Failed to create child article: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isCreatingChild = false;
            StateHasChanged();
        }
    }

    #endregion

    #region Keyboard Shortcuts

    private void OnMetadataDrawerToggle()
    {
        _openMetadata = !_openMetadata;
        InvokeAsync(StateHasChanged);
    }

    private async void HandleSaveShortcut()
    {
        await InvokeAsync(SaveArticle);
    }

    [JSInvokable("HandleCtrlN")]
    public static Task HandleCtrlN()
    {
        OnCtrlNPressed?.Invoke();
        return Task.CompletedTask;
    }

    private static event Action? OnCtrlNPressed;

    private async void HandleCtrlNInstance() => await InvokeAsync(CreateSiblingArticle);

    #endregion

    #region Wiki Link Autocomplete

    [JSInvokable]
    public async Task OnAutocompleteTriggered(string query, double x, double y)
    {
        _autocompletePosition = (x, y);
        _showAutocomplete = true;
        _autocompleteSelectedIndex = 0;

        _autocompleteIsExternalQuery = TryParseExternalAutocompleteQuery(query, out var sourceKey, out var remainder);
        _autocompleteExternalSourceKey = _autocompleteIsExternalQuery ? sourceKey : null;
        _autocompleteQuery = _autocompleteIsExternalQuery ? remainder : query;

        // For external queries (like srd/...), we have different length requirements:
        // - Empty or short remainder: show categories (handled by server)
        // - Any length after category selected: search immediately
        // For internal queries: require 3 characters minimum
        var minLength = _autocompleteIsExternalQuery ? 0 : 3;
        
        if (_autocompleteQuery.Length < minLength)
        {
            _autocompleteSuggestions = new();
            StateHasChanged();
            return;
        }

        _autocompleteLoading = true;
        StateHasChanged();

        try
        {
            var worldId = AppContext.CurrentWorldId ?? _article?.WorldId ?? Guid.Empty;
            
            if (_autocompleteIsExternalQuery)
            {
                var externalSuggestions = await ExternalLinkApiService.GetSuggestionsAsync(
                    worldId,
                    _autocompleteExternalSourceKey ?? string.Empty,
                    _autocompleteQuery,
                    CancellationToken.None);
                _autocompleteSuggestions = externalSuggestions
                    .Select(WikiLinkAutocompleteItem.FromExternal)
                    .ToList();
            }
            else
            {
                var internalSuggestions = await LinkApiService.GetSuggestionsAsync(worldId, _autocompleteQuery);
                _autocompleteSuggestions = internalSuggestions
                    .Select(WikiLinkAutocompleteItem.FromInternal)
                    .ToList();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting autocomplete suggestions");
            _autocompleteSuggestions = new();
        }
        finally
        {
            _autocompleteLoading = false;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public Task OnAutocompleteHidden()
    {
        _showAutocomplete = false;
        _autocompleteSuggestions = new();
        _autocompleteIsExternalQuery = false;
        _autocompleteExternalSourceKey = null;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnAutocompleteArrowDown()
    {
        if (_autocompleteSuggestions.Any())
        {
            _autocompleteSelectedIndex = (_autocompleteSelectedIndex + 1) % _autocompleteSuggestions.Count;
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnAutocompleteArrowUp()
    {
        if (_autocompleteSuggestions.Any())
        {
            _autocompleteSelectedIndex = (_autocompleteSelectedIndex - 1 + _autocompleteSuggestions.Count) % _autocompleteSuggestions.Count;
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnAutocompleteEnter()
    {
        if (_autocompleteSuggestions.Any() && _autocompleteSelectedIndex < _autocompleteSuggestions.Count)
            await OnAutocompleteSelect(_autocompleteSuggestions[_autocompleteSelectedIndex]);
    }

    private Task OnAutocompleteIndexChanged(int index)
    {
        _autocompleteSelectedIndex = index;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task OnAutocompleteSelect(WikiLinkAutocompleteItem suggestion)
    {
        if (_article == null) return;

        try
        {
            // Handle category selection - update the editor text instead of inserting a link
            if (suggestion.IsCategory && !string.IsNullOrEmpty(suggestion.CategoryKey))
            {
                await JSRuntime.InvokeVoidAsync(
                    "updateAutocompleteText",
                    $"tiptap-editor-{_article.Id}",
                    $"{suggestion.Source}/{suggestion.CategoryKey}/");
                
                // Trigger autocomplete again with the new text
                // The user can now type a search term
                return;
            }

            if (suggestion.IsExternal)
            {
                if (string.IsNullOrWhiteSpace(suggestion.Source) || string.IsNullOrWhiteSpace(suggestion.ExternalId))
                {
                    Logger.LogWarning("External suggestion missing source or id");
                    return;
                }

                await JSRuntime.InvokeVoidAsync(
                    "insertExternalLinkToken",
                    $"tiptap-editor-{_article.Id}",
                    suggestion.Source,
                    suggestion.ExternalId,
                    suggestion.Title);
            }
            else
            {
                if (!suggestion.ArticleId.HasValue)
                {
                    Logger.LogWarning("Internal suggestion missing article id");
                    return;
                }

                // If matched via alias, display "Alias ‚Üí Title", otherwise just title
                var displayText = !string.IsNullOrWhiteSpace(suggestion.MatchedAlias)
                    ? $"{suggestion.MatchedAlias} ‚Üí {suggestion.Title}"
                    : suggestion.Title;

                await JSRuntime.InvokeVoidAsync(
                    "insertWikiLink",
                    $"tiptap-editor-{_article.Id}",
                    suggestion.ArticleId.Value.ToString(),
                    displayText);
            }
            _showAutocomplete = false;
            _autocompleteSuggestions = new();
            StateHasChanged();
            await Task.Delay(50);
            await SaveArticle();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error inserting wiki link");
            Snackbar.Add("Failed to insert link", Severity.Error);
        }
    }

    private async Task OnAutocompleteCreate(string articleName)
    {
        if (_autocompleteIsExternalQuery)
        {
            return;
        }

        if (_article == null || string.IsNullOrWhiteSpace(articleName)) return;

        try
        {
            var worldId = AppContext.CurrentWorldId ?? _article.WorldId ?? Guid.Empty;
            var created = await WikiLinkService.CreateArticleFromAutocompleteAsync(articleName, worldId);
            
            if (created == null)
            {
                Snackbar.Add("Failed to create article", Severity.Error);
                return;
            }

            await JSRuntime.InvokeVoidAsync("insertWikiLink", $"tiptap-editor-{_article.Id}", created.Id.ToString(), created.Title);
            _showAutocomplete = false;
            _autocompleteSuggestions = new();
            StateHasChanged();

            await Task.Delay(50);
            await SaveArticle();
            await TreeState.RefreshAsync();
            Snackbar.Add($"Created and linked '{articleName}'", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating article from autocomplete");
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private static bool TryParseExternalAutocompleteQuery(string query, out string sourceKey, out string remainder)
    {
        sourceKey = string.Empty;
        remainder = string.Empty;

        if (string.IsNullOrWhiteSpace(query))
        {
            return false;
        }

        var slashIndex = query.IndexOf('/');
        if (slashIndex <= 0)
        {
            return false;
        }

        sourceKey = query.Substring(0, slashIndex).Trim().ToLowerInvariant();
        remainder = query.Substring(slashIndex + 1);

        return !string.IsNullOrWhiteSpace(sourceKey);
    }

    [JSInvokable]
    public async Task OnWikiLinkClicked(string targetArticleId)
    {
        if (!Guid.TryParse(targetArticleId, out var articleId)) return;

        try
        {
            var path = await ArticleCache.GetNavigationPathAsync(articleId);
            if (!string.IsNullOrEmpty(path))
                Navigation.NavigateTo($"/article/{path}");
            else
                Snackbar.Add("Article not found", Severity.Warning);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error navigating to wiki link: {ArticleId}", targetArticleId);
            Snackbar.Add("Failed to navigate to article", Severity.Error);
        }
    }

    [JSInvokable]
    public async Task<string?> GetArticlePath(string targetArticleId)
    {
        if (!Guid.TryParse(targetArticleId, out var articleId)) return null;

        try
        {
            return await ArticleCache.GetArticlePathAsync(articleId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting article path: {ArticleId}", targetArticleId);
            return null;
        }
    }

    [JSInvokable]
    public async Task<object?> GetArticleSummaryPreview(string targetArticleId)
    {
        if (!Guid.TryParse(targetArticleId, out var articleId)) return null;

        try
        {
            var preview = await SummaryApi.GetSummaryPreviewAsync(articleId);
            if (preview == null || !preview.HasSummary) return null;

            return new
            {
                title = preview.Title,
                summary = preview.Summary,
                templateName = preview.TemplateName
            };
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting summary preview: {ArticleId}", targetArticleId);
            return null;
        }
    }

    [JSInvokable]
    public async Task OnExternalLinkClicked(string source, string id, string title)
    {
        if (string.IsNullOrWhiteSpace(source) || string.IsNullOrWhiteSpace(id)) return;

        _externalPreviewOpen = true;
        _externalPreviewLoading = true;
        _externalPreviewError = null;
        _externalPreviewSource = source;
        _externalPreviewId = id;
        _externalPreviewTitle = string.IsNullOrWhiteSpace(title) ? "External Link" : title;
        _externalPreviewContent = null;
        StateHasChanged();

        var cacheKey = GetExternalCacheKey(source, id);
        if (_externalLinkCache.TryGetValue(cacheKey, out var cached))
        {
            _externalPreviewContent = cached;
            _externalPreviewLoading = false;
            StateHasChanged();
            return;
        }

        try
        {
            var content = await ExternalLinkApiService.GetContentAsync(source, id, CancellationToken.None);

            if (content == null || string.IsNullOrWhiteSpace(content.Markdown))
            {
                _externalPreviewError = "No content available.";
                _externalPreviewContent = null;
            }
            else
            {
                _externalPreviewContent = content;
                _externalLinkCache[cacheKey] = content;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading external link preview for {Source} {Id}", source, id);
            _externalPreviewError = "Failed to load external content.";
            _externalPreviewContent = null;
        }
        finally
        {
            _externalPreviewLoading = false;
            StateHasChanged();
        }
    }

    private void CloseExternalPreview()
    {
        _externalPreviewOpen = false;
        StateHasChanged();
    }

    private static string GetExternalCacheKey(string source, string id) => $"{source}:{id}".ToLowerInvariant();

    #endregion
}
