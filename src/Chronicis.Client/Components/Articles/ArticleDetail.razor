@using Chronicis.Client.Components.Shared
@using Chronicis.Client.Components.Characters
@using Chronicis.Client.Utilities
@using Chronicis.Shared.Enums
@using Chronicis.Shared.Utilities
@using Blazored.LocalStorage
@using Microsoft.JSInterop
@inject IArticleApiService ArticleApi
@inject ILinkApiService LinkApiService
@inject IWikiLinkService WikiLinkService
@inject IAISummaryApiService SummaryApi
@inject ITreeStateService TreeState
@inject IAppContextService AppContext
@inject IBreadcrumbService BreadcrumbService
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@inject ILocalStorageService LocalStorage
@inject ILogger<ArticleDetail> Logger
@inject IArticleCacheService ArticleCache

@implements IDisposable

@if (_isLoading)
{
    <LoadingSkeleton />
}
else if (_article == null)
{
    <EmptyState 
        Icon="üìù"
        Title="No Article Selected"
        Message="Select an article from the tree to view and edit its content."
        ActionText="Create New Article"
        OnActionClick="CreateRootArticle" />
}
else
{
    <style>
        .mud-input.mud-input-underline:before,
        .mud-input.mud-input-underline:after,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):before,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):after {
            border-bottom: none !important;        
        }

        .mud-input,
        .chronicis-editor-content {
            border: solid 1px #c7c7c4;
            border-radius: 4px;
        }

        .chronicis-article-title .mud-input {
            padding-left:8px;
        }
    </style>

    <MudPaper Elevation="2" Class="chronicis-article-card chronicis-fade-in">

        <!-- Article Header (Breadcrumbs, Icon, Title, Divider) -->
        <ArticleHeader Breadcrumbs="_breadcrumbs"
                       @bind-Title="_editTitle"
                       IconEmoji="@_article.IconEmoji"
                       OnIconChanged="HandleIconChanged"
                       OnTitleEdited="HandleTitleEdited"
                       OnEnterPressed="SaveArticle"
                       OnMetadataToggle="ToggleMetadata"
                       ShouldFocusTitle="_shouldFocusTitle"
                       ShouldFocusTitleChanged="HandleFocusTitleChanged" />

        @* Character Claim Button - only show for Character type articles *@
        @if (_article.Type == ArticleType.Character)
        {
            <div class="mb-3">
                <CharacterClaimButton CharacterId="@_article.Id" />
            </div>
        }

        <!-- TipTap Editor Container -->
        <div id="tiptap-editor-@_article.Id" class="chronicis-editor-container mb-4"></div>

        <!-- AI Summary Section -->
        <AISummarySection EntityId="@_article.Id"
                          EntityType="Article"
                          IsExpanded="@_isSummaryExpanded"
                          IsExpandedChanged="@((expanded) => _isSummaryExpanded = expanded)" />

        <!-- Action Bar (Save Status + Buttons) -->
        <ArticleActionBar IsSaving="_isSaving"
                          IsAutoLinking="_isAutoLinking"
                          HasUnsavedChanges="_hasUnsavedChanges"
                          LastSaveTime="@_lastSaveTime"
                          OnSave="SaveArticle"
                          OnDelete="DeleteArticle"
                          OnAutoLink="AutoLinkArticle" />
    </MudPaper>

    <!-- Metadata Drawer -->
    <ArticleMetadataDrawer @ref="_metadataDrawer"
                           Article="_article"
                           @bind-IsOpen="_openMetadata" />

    <!-- Wiki Link Autocomplete -->
    @if (_showAutocomplete && _article != null)
    {
        <WikiLinkAutocomplete Suggestions="@_autocompleteSuggestions"
                              Loading="@_autocompleteLoading"
                              SelectedIndex="@_autocompleteSelectedIndex"
                              SelectedIndexChanged="OnAutocompleteIndexChanged"
                              OnSelect="OnAutocompleteSelect"
                              OnCreate="OnAutocompleteCreate"
                              Position="@_autocompletePosition"
                              Query="@_autocompleteQuery" />
    }
}

@code {
    // Article state
    private ArticleDto? _article;
    private List<BreadcrumbItem>? _breadcrumbs;
    private string _editTitle = string.Empty;
    private string _editBody = string.Empty;
    
    // UI state
    private bool _isLoading = false;
    private bool _isSaving = false;
    private bool _isAutoLinking = false;
    private bool _hasUnsavedChanges = false;
    private bool _editorInitialized = false;
    private string _lastSaveTime = "just now";
    private bool _openMetadata = false;
    private bool _isSummaryExpanded = false;
    private bool _shouldFocusTitle = false;
    
    // Timer and references
    private Timer? _autoSaveTimer;
    private DotNetObjectReference<ArticleDetail>? _dotNetHelper;
    private ArticleMetadataDrawer? _metadataDrawer;
    private bool _disposed = false;
    
    // Autocomplete state
    private bool _showAutocomplete = false;
    private bool _autocompleteLoading = false;
    private List<LinkSuggestionDto> _autocompleteSuggestions = new();
    private int _autocompleteSelectedIndex = 0;
    private (double X, double Y) _autocompletePosition = (0, 0);
    private string _autocompleteQuery = string.Empty;
    
    private const string LastArticlePathKey = "chronicis_last_article_path";

    #region Lifecycle

    protected override async Task OnInitializedAsync()
    {
        TreeState.OnStateChanged += OnTreeStateChanged;
        _dotNetHelper = DotNetObjectReference.Create(this);
        await Task.CompletedTask;
    }

    protected override void OnInitialized()
    {
        OnCtrlNPressed += HandleCtrlNInstance;
        base.OnInitialized();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && TreeState.SelectedArticleId.HasValue)
        {
            await LoadArticleAsync(TreeState.SelectedArticleId.Value);
            StateHasChanged();
            await Task.Delay(100);
            await InitializeEditor();
        }
    }

    public void Dispose()
    {
        _disposed = true;
        TreeState.OnStateChanged -= OnTreeStateChanged;
        OnCtrlNPressed -= HandleCtrlNInstance;
        _autoSaveTimer?.Dispose();
        
        // Clear and dispose the DotNetObjectReference
        var helper = _dotNetHelper;
        _dotNetHelper = null;
        helper?.Dispose();
    }

    #endregion

    #region Header Event Handlers

    private void HandleTitleEdited() => _hasUnsavedChanges = true;

    private async Task HandleIconChanged(string? newIcon)
    {
        if (_article == null || _isSaving) return;

        _article.IconEmoji = newIcon;
        _isSaving = true;
        StateHasChanged();

        try
        {
            var updateDto = new ArticleUpdateDto
            {
                Title = _editTitle?.Trim() ?? string.Empty,
                Body = _editBody,
                EffectiveDate = _article.EffectiveDate,
                IconEmoji = newIcon
            };

            await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);
            _article.ModifiedAt = DateTime.Now;
            _lastSaveTime = "just now";

            await TreeState.RefreshAsync();
            TreeState.UpdateNodeDisplay(_article.Id, _editTitle ?? string.Empty, newIcon);

            Snackbar.Add($"Icon {(string.IsNullOrEmpty(newIcon) ? "removed" : "updated")}", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save icon: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }

    private void HandleFocusTitleChanged(bool value) => _shouldFocusTitle = value;

    private void ToggleMetadata() => _openMetadata = !_openMetadata;

    #endregion

    #region Article Loading

    private async void OnTreeStateChanged()
    {
        if (_disposed) return;
        
        await InvokeAsync(async () =>
        {
            if (_disposed) return;
            
            try
            {
                if (_editorInitialized && _article != null)
                {
                    await JSRuntime.InvokeVoidAsync("destroyTipTapEditor", $"tiptap-editor-{_article.Id}");
                }

                _editorInitialized = false;

                if (_disposed) return;

                if (TreeState.SelectedArticleId.HasValue && TreeState.SelectedArticleId.Value != Guid.Empty)
                {
                    await LoadArticleAsync(TreeState.SelectedArticleId.Value);
                }
                else
                {
                    _article = null;
                    if (!_disposed)
                    {
                        await JSRuntime.InvokeVoidAsync("eval", "document.title = 'Chronicis'");
                    }
                }

                if (_disposed) return;
                StateHasChanged();

                if (_article != null && !_disposed)
                {
                    await Task.Delay(100);
                    if (!_disposed)
                    {
                        await InitializeEditor();
                    }
                }
            }
            catch (ObjectDisposedException)
            {
                // Component was disposed during async operation - this is expected during navigation
            }
            catch (JSDisconnectedException)
            {
                // JS runtime disconnected - this is expected during navigation
            }
        });
    }

    private async Task LoadArticleAsync(Guid articleId)
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            _article = await ArticleApi.GetArticleAsync(articleId);
            _editTitle = _article?.Title ?? string.Empty;
            _editBody = _article?.Body ?? string.Empty;
            _hasUnsavedChanges = false;

            if (_article != null)
            {
                ArticleCache.CacheArticle(_article);
            }

            LoadBreadcrumbs();
            await UpdatePageTitle();
            await SaveLastArticlePath();

            if (string.IsNullOrEmpty(_editTitle) || TreeState.ShouldFocusTitle)
            {
                _shouldFocusTitle = true;
                TreeState.ShouldFocusTitle = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load article: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void LoadBreadcrumbs()
    {
        if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
        {
            _breadcrumbs = BreadcrumbService.ForArticle(_article.Breadcrumbs);
        }
        else
        {
            _breadcrumbs = new List<BreadcrumbItem> { new("Dashboard", href: "/dashboard") };
        }
    }

    private async Task UpdatePageTitle()
    {
        var pageTitle = string.IsNullOrEmpty(_article?.Title) ? "Untitled - Chronicis" : $"{_article.Title} - Chronicis";
        await JSRuntime.InvokeVoidAsync("eval", $"document.title = '{JsUtilities.EscapeForJs(pageTitle)}'");
    }

    private async Task SaveLastArticlePath()
    {
        if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
        {
            var path = BreadcrumbService.BuildArticleUrl(_article.Breadcrumbs);
            await LocalStorage.SetItemAsStringAsync(LastArticlePathKey, path);
        }
    }

    #endregion

    #region Editor

    private async Task InitializeEditor()
    {
        if (_article != null && !_editorInitialized && !_disposed && _dotNetHelper != null)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("initializeTipTapEditor", $"tiptap-editor-{_article.Id}", _editBody, _dotNetHelper);
                
                if (_disposed) return;
                
                await JSRuntime.InvokeVoidAsync("initializeWikiLinkAutocomplete", $"tiptap-editor-{_article.Id}", _dotNetHelper);
                _editorInitialized = true;
            }
            catch (ObjectDisposedException)
            {
                // Component was disposed during async operation - this is expected during navigation
            }
            catch (JSDisconnectedException)
            {
                // JS runtime disconnected - this is expected during navigation
            }
            catch (Exception ex)
            {
                if (!_disposed)
                {
                    Snackbar.Add($"Failed to initialize editor: {ex.Message}", Severity.Warning);
                }
            }
        }
    }

    [JSInvokable]
    public void OnEditorUpdate(string markdown)
    {
        _editBody = markdown;
        _hasUnsavedChanges = true;
        _autoSaveTimer?.Dispose();
        _autoSaveTimer = new Timer(async _ => await AutoSave(), null, 500, Timeout.Infinite);
    }

    private async Task AutoSave()
    {
        await InvokeAsync(async () =>
        {
            if (_hasUnsavedChanges && !_isSaving)
                await SaveArticle();
        });
    }

    #endregion

    #region Save & Delete

    private async Task SaveArticle()
    {
        if (_article == null || _isSaving) return;

        _isSaving = true;
        StateHasChanged();

        try
        {
            var originalTitle = _article.Title;
            var newTitle = _editTitle?.Trim() ?? string.Empty;
            var titleChanged = originalTitle != newTitle;
            string? newSlug = null;
            
            if (titleChanged)
            {
                var suggestedSlug = SlugGenerator.GenerateSlug(newTitle);
                if (suggestedSlug != _article.Slug)
                    newSlug = suggestedSlug;
            }

            var updateDto = new ArticleUpdateDto
            {
                Title = newTitle,
                Slug = newSlug,
                Body = _editBody,
                EffectiveDate = _article.EffectiveDate,
                IconEmoji = _article.IconEmoji
            };

            await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);
            ArticleCache.InvalidateCache();

            _article.Title = newTitle;
            _article.Body = _editBody;
            _article.ModifiedAt = DateTime.Now;
            _hasUnsavedChanges = false;
            _lastSaveTime = "just now";

            if (newSlug != null || titleChanged)
            {
                await UpdatePageTitle();
                TreeState.UpdateNodeDisplay(_article.Id, newTitle, _article.IconEmoji);
            }

            if (newSlug != null)
            {
                TreeState.ExpandPathToAndSelect(_article.Id);
                _article = await ArticleApi.GetArticleAsync(_article.Id);
                
                if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
                {
                    var path = BreadcrumbService.BuildArticleUrl(_article.Breadcrumbs);
                    Navigation.NavigateTo(path, replace: true);
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
            if (_metadataDrawer != null)
                await _metadataDrawer.RefreshPanelsAsync();
        }
    }

    private async Task DeleteArticle()
    {
        if (_article == null) return;

        var message = $"Are you sure you want to delete '{_article.Title}'?";
        if (_article.ChildCount > 0)
        {
            var childText = _article.ChildCount == 1 ? "1 child article" : $"{_article.ChildCount} child articles";
            message = $"Are you sure you want to delete '{_article.Title}'?\n\n‚ö†Ô∏è WARNING: This will also delete {childText} and all their descendants.";
        }
        message += "\n\nThis action cannot be undone.";

        if (!await JSRuntime.InvokeAsync<bool>("confirm", message)) return;

        try
        {
            await ArticleApi.DeleteArticleAsync(_article.Id);
            ArticleCache.InvalidateCache();
            Snackbar.Add("Article deleted successfully", Severity.Success);
            await TreeState.RefreshAsync();
            _article = null;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    private async Task AutoLinkArticle()
    {
        if (_article == null || _isAutoLinking) return;

        _isAutoLinking = true;
        StateHasChanged();

        try
        {
            var result = await LinkApiService.AutoLinkAsync(_article.Id, _editBody);

            if (result == null)
            {
                Snackbar.Add("Failed to scan for links", Severity.Error);
                return;
            }

            if (result.LinksFound == 0)
            {
                Snackbar.Add("No linkable content found", Severity.Info);
                return;
            }

            var matchList = string.Join("\n", result.Matches.Select(m => $"‚Ä¢ \"{m.MatchedText}\" ‚Üí {m.ArticleTitle}"));
            if (!await JSRuntime.InvokeAsync<bool>("confirm", $"Found {result.LinksFound} potential link(s):\n\n{matchList}\n\nApply these links?"))
                return;

            _editBody = result.ModifiedBody;
            await JSRuntime.InvokeVoidAsync("setTipTapContent", $"tiptap-editor-{_article.Id}", result.ModifiedBody);
            _hasUnsavedChanges = true;
            await SaveArticle();
            Snackbar.Add($"Added {result.LinksFound} link(s)", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error auto-linking article {ArticleId}", _article.Id);
            Snackbar.Add($"Failed to auto-link: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isAutoLinking = false;
            StateHasChanged();
        }
    }

    #endregion

    #region Article Creation

    private async Task CreateRootArticle()
    {
        var worldId = AppContext.CurrentWorldId;
        if (!worldId.HasValue || worldId == Guid.Empty)
        {
            Snackbar.Add("Please select a World first", Severity.Warning);
            return;
        }

        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = "Untitled",
                Body = string.Empty,
                ParentId = null,
                EffectiveDate = DateTime.Now,
                WorldId = worldId.Value
            };

            await ArticleApi.CreateArticleAsync(createDto);
            await TreeState.RefreshAsync();
            Snackbar.Add("Article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateSiblingArticle()
    {
        if (_article == null) return;

        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = string.Empty,
                Body = string.Empty,
                ParentId = _article.ParentId,
                EffectiveDate = DateTime.Now,
                WorldId = _article.WorldId,
                CampaignId = _article.CampaignId
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            if (created == null)
            {
                Snackbar.Add("Failed to create article", Severity.Error);
                return;
            }
            
            await TreeState.RefreshAsync();
            TreeState.ExpandPathToAndSelect(created.Id);
            
            var path = created.Breadcrumbs?.Any() == true 
                ? BreadcrumbService.BuildArticleUrl(created.Breadcrumbs)
                : $"/article/{created.Slug}";
            Navigation.NavigateTo(path);
            Snackbar.Add("New article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    #endregion

    #region Keyboard Shortcuts

    [JSInvokable("HandleCtrlN")]
    public static Task HandleCtrlN()
    {
        OnCtrlNPressed?.Invoke();
        return Task.CompletedTask;
    }

    private static event Action? OnCtrlNPressed;

    private async void HandleCtrlNInstance() => await InvokeAsync(CreateSiblingArticle);

    #endregion

    #region Wiki Link Autocomplete

    [JSInvokable]
    public async Task OnAutocompleteTriggered(string query, double x, double y)
    {
        _autocompletePosition = (x, y);
        _autocompleteQuery = query;
        _showAutocomplete = true;
        _autocompleteSelectedIndex = 0;
        
        if (query.Length < 3)
        {
            _autocompleteSuggestions = new();
            StateHasChanged();
            return;
        }

        _autocompleteLoading = true;
        StateHasChanged();

        try
        {
            var worldId = AppContext.CurrentWorldId ?? _article?.WorldId ?? Guid.Empty;
            _autocompleteSuggestions = await LinkApiService.GetSuggestionsAsync(worldId, query);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting autocomplete suggestions");
            _autocompleteSuggestions = new();
        }
        finally
        {
            _autocompleteLoading = false;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public Task OnAutocompleteHidden()
    {
        _showAutocomplete = false;
        _autocompleteSuggestions = new();
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnAutocompleteArrowDown()
    {
        if (_autocompleteSuggestions.Any())
        {
            _autocompleteSelectedIndex = (_autocompleteSelectedIndex + 1) % _autocompleteSuggestions.Count;
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnAutocompleteArrowUp()
    {
        if (_autocompleteSuggestions.Any())
        {
            _autocompleteSelectedIndex = (_autocompleteSelectedIndex - 1 + _autocompleteSuggestions.Count) % _autocompleteSuggestions.Count;
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnAutocompleteEnter()
    {
        if (_autocompleteSuggestions.Any() && _autocompleteSelectedIndex < _autocompleteSuggestions.Count)
            await OnAutocompleteSelect(_autocompleteSuggestions[_autocompleteSelectedIndex]);
    }

    private Task OnAutocompleteIndexChanged(int index)
    {
        _autocompleteSelectedIndex = index;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task OnAutocompleteSelect(LinkSuggestionDto suggestion)
    {
        if (_article == null) return;

        try
        {
            await JSRuntime.InvokeVoidAsync("insertWikiLink", $"tiptap-editor-{_article.Id}", suggestion.ArticleId.ToString(), suggestion.Title);
            _showAutocomplete = false;
            _autocompleteSuggestions = new();
            StateHasChanged();
            await Task.Delay(50);
            await SaveArticle();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error inserting wiki link");
            Snackbar.Add("Failed to insert link", Severity.Error);
        }
    }

    private async Task OnAutocompleteCreate(string articleName)
    {
        if (_article == null || string.IsNullOrWhiteSpace(articleName)) return;

        try
        {
            var worldId = AppContext.CurrentWorldId ?? _article.WorldId ?? Guid.Empty;
            var created = await WikiLinkService.CreateArticleFromAutocompleteAsync(articleName, worldId);
            
            if (created == null)
            {
                Snackbar.Add("Failed to create article", Severity.Error);
                return;
            }

            await JSRuntime.InvokeVoidAsync("insertWikiLink", $"tiptap-editor-{_article.Id}", created.Id.ToString(), created.Title);
            _showAutocomplete = false;
            _autocompleteSuggestions = new();
            StateHasChanged();

            await Task.Delay(50);
            await SaveArticle();
            await TreeState.RefreshAsync();
            Snackbar.Add($"Created and linked '{articleName}'", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating article from autocomplete");
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    [JSInvokable]
    public async Task OnWikiLinkClicked(string targetArticleId)
    {
        if (!Guid.TryParse(targetArticleId, out var articleId)) return;

        try
        {
            var path = await ArticleCache.GetNavigationPathAsync(articleId);
            if (!string.IsNullOrEmpty(path))
                Navigation.NavigateTo($"/article/{path}");
            else
                Snackbar.Add("Article not found", Severity.Warning);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error navigating to wiki link: {ArticleId}", targetArticleId);
            Snackbar.Add("Failed to navigate to article", Severity.Error);
        }
    }

    [JSInvokable]
    public async Task<string?> GetArticlePath(string targetArticleId)
    {
        if (!Guid.TryParse(targetArticleId, out var articleId)) return null;

        try
        {
            return await ArticleCache.GetArticlePathAsync(articleId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting article path: {ArticleId}", targetArticleId);
            return null;
        }
    }

    [JSInvokable]
    public async Task<object?> GetArticleSummaryPreview(string targetArticleId)
    {
        if (!Guid.TryParse(targetArticleId, out var articleId)) return null;

        try
        {
            var preview = await SummaryApi.GetSummaryPreviewAsync(articleId);
            if (preview == null || !preview.HasSummary) return null;

            return new
            {
                title = preview.Title,
                summary = preview.Summary,
                templateName = preview.TemplateName
            };
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting summary preview: {ArticleId}", targetArticleId);
            return null;
        }
    }

    #endregion
}
