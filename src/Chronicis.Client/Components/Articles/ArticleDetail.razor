@using Chronicis.Client.Components.Shared
@using MudBlazor.Charts
@using Chronicis.Client.Components.Hashtags
@inject IArticleApiService ArticleApi
@inject ITreeStateService TreeState
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@inject IDialogService DialogService

@implements IDisposable

@if (_isLoading)
{
    <LoadingSkeleton />
}
else if (_article == null)
{
    <EmptyState 
        Icon="üìù"
        Title="No Article Selected"
        Message="Select an article from the tree to view and edit its content."
        ActionText="Create New Article"
        OnActionClick="CreateRootArticle" />
}
else
{
    <style>
        .metadata-drawer,
        .metadata-drawer .mud-drawer-content {
            background-color: transparent !important;
            border-right-color: transparent;
        }
            .metadata-drawer .mud-drawer-content {
                padding: 8px;
                background-color: var(--chronicis-soft-off-white) !important;
            }
            .metadata-drawer.mud-drawer-persistent {
                height:auto !important;
            }

        .mud-input.mud-input-underline:before,
        .mud-input.mud-input-underline:after,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):before,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):after {
            border-bottom: none !important;        
        }

        .mud-input,
        .chronicis-editor-content {
            border: solid 1px #c7c7c4;
            padding:8px;
            border-radius: 4px;
        }
    </style>

    <MudPaper Elevation="2" Class="chronicis-article-card chronicis-fade-in">

        <div class="mud-toolbar">
        <!-- Breadcrumbs -->
        @if (_breadcrumbs != null && _breadcrumbs.Any())
        {
            <MudBreadcrumbs Items="_breadcrumbs">
                <ItemTemplate Context="item">
                    <MudLink Href="@item.Href" Class="chronicis-breadcrumb-link">
                        @item.Text
                    </MudLink>
                </ItemTemplate>
            </MudBreadcrumbs>
        }
        <MudSpacer />
    <!-- Metadata Toggle Button -->
            <MudTooltip Text="Metadata">
                <MudIconButton Color="Color.Inherit"
                               OnClick="@ToggleMetadata"
                               Icon="@Icons.Material.Filled.ChromeReaderMode"
                               Class="mt-0"
                Edge="Edge.End">
                </MudIconButton>
            </MudTooltip>
        </div>

        <!-- Title Row with Emoji Picker -->
        <div class="d-flex align-center mb-3">
            <!-- Emoji Picker Button -->
            <EmojiPickerButton 
                CurrentEmoji="@_article.IconEmoji"
                OnEmojiChanged="OnIconEmojiChanged"
                IsSaving="@_isSaving" />
            
            <!-- Title (Always Editable) - NO AUTO-SAVE -->
            <MudTextField @ref="_titleField"
                          @bind-Value="_editTitle"
                          Variant="Variant.Text"
                          Placeholder="Untitled Article"
                          Class="chronicis-article-title flex-grow-1"
                          Style="font-size: 2rem; font-family: var(--chronicis-font-heading);"
                          Immediate="true"
                          @onkeyup="@(() => OnTitleChanged())"
                          @onkeydown="@OnTitleKeyDown"
                          Underline="false"/>
        </div>

        <!-- Divider -->
        <div class="chronicis-rune-divider mb-3"></div>

        <!-- TipTap Editor Container (from Phase 4) -->
        <div id="tiptap-editor-@_article.Id" class="chronicis-editor-container mb-4"></div>

        <!-- AI Summary Section -->
        <AISummarySection ArticleId="@_article.Id"
                          IsExpanded="@_isSummaryExpanded"
                          IsExpandedChanged="@((expanded) => _isSummaryExpanded = expanded)" />

        <!-- Save Status -->
        <div class="chronicis-flex-between mt-4">
            <div class="chronicis-save-status @_saveStatusClass">
                @if (_isSaving)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    <span>Saving...</span>
                }
                else if (_hasUnsavedChanges)
                {
                    <span>‚ö†Ô∏è Unsaved changes</span>
                }
                else
                {
                    <span>‚úì Saved @_lastSaveTime</span>
                }
            </div>

            <div class="chronicis-flex" style="gap: 8px;">
                <MudButton 
                    Variant="Variant.Filled" 
                    Color="Color.Primary"
                    OnClick="SaveArticle"
                    Disabled="_isSaving"
                    StartIcon="@Icons.Material.Filled.Save">
                    Save
                </MudButton>
                
                <MudButton 
                    Variant="Variant.Outlined" 
                    Color="Color.Error"
                    OnClick="DeleteArticle"
                    StartIcon="@Icons.Material.Filled.Delete">
                    Delete
                </MudButton>
            </div>
        </div>
    </MudPaper>
    <!-- Metadata -->
    <MudDrawer @bind-Open="@_openMetadata"
               Fixed="true"
               Anchor="Anchor.End"
               Elevation="9999"
               Variant="@DrawerVariant.Persistent"
               ClipMode="@DrawerClipMode.Always"
               Class="metadata-drawer">
        <MudDrawerHeader>
            <MudText Typo="Typo.h6">Metadata</MudText>
        </MudDrawerHeader>
        <MudDrawerContainer>
            <MudList T="string">
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Article ID</MudText>
                        <MudText Typo="Typo.body2">@_article.Id</MudText>
                </MudListItem>
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Effective Date</MudText>
                        <MudText Typo="Typo.body2">
                            @_article.EffectiveDate.ToString("MMMM d, yyyy 'at' h:mm tt")
                        </MudText>
                </MudListItem>
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Created Date</MudText>
                        <MudText Typo="Typo.body2">
                            @_article.CreatedDate.ToString("MMMM d, yyyy 'at' h:mm tt")
                        </MudText>
                </MudListItem>
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Modified Date</MudText>
                        <MudText Typo="Typo.body2">
                            @_article.ModifiedDate?.ToString("MMMM d, yyyy 'at' h:mm tt")
                        </MudText>
                </MudListItem>
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Icon Emoji</MudText>
                        <MudText Typo="Typo.body2">
                            @(_article.IconEmoji ?? "(None)")
                        </MudText>
                </MudListItem>
            </MudList>
            <BacklinksPanel ArticleId="@_article.Id" />
        </MudDrawerContainer>
    </MudDrawer>
}

@code {
    private ArticleDto? _article;
    private List<BreadcrumbItem>? _breadcrumbs;
    private string _editTitle = string.Empty;
    private string _editBody = string.Empty;
    private bool _isLoading = false;
    private bool _isSaving = false;
    private bool _hasUnsavedChanges = false;
    private bool _editorInitialized = false;
    private string _lastSaveTime = "just now";
    private Timer? _autoSaveTimer;
    private MudTextField<string>? _titleField;
    private DotNetObjectReference<ArticleDetail>? _dotNetHelper;
    private bool _openMetadata = false;
    private bool _isSummaryExpanded = false;

    private string _saveStatusClass => _isSaving ? "saving" : _hasUnsavedChanges ? "unsaved" : "saved";

    protected override async Task OnInitializedAsync()
    {
        TreeState.OnStateChanged += OnTreeStateChanged;
        _dotNetHelper = DotNetObjectReference.Create(this);

        // NEW: Listen for hashtag link requests
        await JSRuntime.InvokeVoidAsync("eval", @"
        document.addEventListener('hashtag-link-requested', function(e) {
            DotNet.invokeMethodAsync('Chronicis.Client', 'HandleHashtagLinkRequest', e.detail.hashtagName);
        });
    ");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // ONLY handle first render
        if (firstRender && TreeState.SelectedArticleId.HasValue)
        {
            await LoadArticleAsync(TreeState.SelectedArticleId.Value);
            StateHasChanged();
            await Task.Delay(100);
            await InitializeEditor();
        }
    }

    private async void OnTreeStateChanged()
    {
        await InvokeAsync(async () =>
        {
            if (_editorInitialized && _article != null)
            {
                await JSRuntime.InvokeVoidAsync("destroyTipTapEditor", $"tiptap-editor-{_article.Id}");
            }

            _editorInitialized = false;

            // Check if article is selected AND valid (> 0)
            if (TreeState.SelectedArticleId.HasValue && TreeState.SelectedArticleId.Value > 0)
            {
                await LoadArticleAsync(TreeState.SelectedArticleId.Value);
            }
            else
            {
                _article = null;
                
                // Reset page title to default
                await JSRuntime.InvokeVoidAsync("eval", "document.title = 'Chronicis'");
            }

            StateHasChanged();
            
            if (_article != null)
            {
                await Task.Delay(100);
                await InitializeEditor();
            }
        });
    }

    private async Task LoadArticleAsync(int articleId)
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            _article = await ArticleApi.GetArticleAsync(articleId);
            _editTitle = _article?.Title ?? string.Empty;
            _editBody = _article?.Body ?? string.Empty;
            _hasUnsavedChanges = false;
            await LoadBreadcrumbsAsync(articleId);

            // Update browser page title
            var pageTitle = string.IsNullOrEmpty(_article?.Title) 
                ? "Untitled - Chronicis" 
                : $"{_article.Title} - Chronicis";
            await JSRuntime.InvokeVoidAsync("eval", $"document.title = '{EscapeForJs(pageTitle)}'");

            // Focus title if it's empty (new article)
            if (string.IsNullOrEmpty(_editTitle))
            {
                await Task.Delay(100);
                _titleField?.FocusAsync().GetAwaiter().GetResult();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load article: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    // Helper to escape strings for JavaScript
    private static string EscapeForJs(string text)
    {
        return text.Replace("'", "\\'").Replace("\n", "\\n").Replace("\r", "\\r");
    }

    private async Task LoadBreadcrumbsAsync(int articleId)
    {
        _breadcrumbs = new List<BreadcrumbItem>
        {
            new BreadcrumbItem("Home", href: "/")
        };

        // Add all ancestors from the API response (already includes current article)
        if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
        {
            for (int i = 0; i < _article.Breadcrumbs.Count; i++)
            {
                var crumb = _article.Breadcrumbs[i];
                var isLast = i == _article.Breadcrumbs.Count - 1;
                var slug = CreateSlug(crumb.Title);
                
                _breadcrumbs.Add(new BreadcrumbItem(
                    crumb.Title,
                    href: isLast ? null : $"/article/{slug}",
                    disabled: isLast
                ));
            }
        }
    }

    private async Task InitializeEditor()
    {
        if (_article != null && !_editorInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync(
                    "initializeTipTapEditor",
                    $"tiptap-editor-{_article.Id}",
                    _editBody,
                    _dotNetHelper
                );
                _editorInitialized = true;
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to initialize editor: {ex.Message}", Severity.Warning);
            }
        }
    }

    [JSInvokable]
    public void OnEditorUpdate(string markdown)
    {
        _editBody = markdown;
        OnContentChanged();
    }

    // NEW: Title changes only mark as unsaved, no auto-save
    private void OnTitleChanged()
    {
        _hasUnsavedChanges = true;
        // No auto-save timer for title changes
    }

    // Handle emoji icon changes - auto-save immediately
    private async Task OnIconEmojiChanged(string? newEmoji)
    {
        if (_article == null || _isSaving) return;

        // Update local state
        _article.IconEmoji = newEmoji;
        
        // Save immediately
        _isSaving = true;
        StateHasChanged();

        try
        {
            var updateDto = new ArticleUpdateDto
            {
                Title = _editTitle?.Trim() ?? string.Empty,
                Body = _editBody,
                EffectiveDate = _article.EffectiveDate,
                IconEmoji = newEmoji
            };

            await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);
            _article.ModifiedDate = DateTime.Now;
            _lastSaveTime = "just now";

            // Refresh tree to show updated icon
            TreeState.RefreshTree();

            var action = string.IsNullOrEmpty(newEmoji) ? "removed" : "updated";
            Snackbar.Add($"Icon {action}", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save icon: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }

    // NEW: Handle Enter key in title field
    private async Task OnTitleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SaveArticle();
        }
    }

    // UPDATED: Only body content triggers auto-save
    private void OnContentChanged()
    {
        _hasUnsavedChanges = true;
        _autoSaveTimer?.Dispose();
        _autoSaveTimer = new Timer(async _ => await AutoSave(), null, 500, Timeout.Infinite);
    }

    private async Task AutoSave()
    {
        await InvokeAsync(async () =>
        {
            if (_hasUnsavedChanges && !_isSaving)
            {
                await SaveArticle();
            }
        });
    }

    // UPDATED: Save with title change detection and URL update
    private async Task SaveArticle()
    {
        if (_article == null || _isSaving) return;

        _isSaving = true;
        StateHasChanged();

        try
        {
            // Track if title changed
            var originalTitle = _article.Title;
            var newTitle = _editTitle?.Trim() ?? string.Empty;
            var titleChanged = originalTitle != newTitle;

            // Create update DTO from current state
            var updateDto = new ArticleUpdateDto
            {
                Title = newTitle,
                Body = _editBody,
                EffectiveDate = _article.EffectiveDate,
                IconEmoji = _article.IconEmoji
            };

            await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);

            // Update local article with changes
            _article.Title = newTitle;
            _article.Body = _editBody;
            _article.ModifiedDate = DateTime.Now;

            _hasUnsavedChanges = false;
            _lastSaveTime = "just now";

            // If title changed, update URL and refresh tree
            if (titleChanged)
            {
                var newSlug = CreateSlug(newTitle);
                
                // Update browser page title
                var pageTitle = string.IsNullOrEmpty(newTitle) 
                    ? "Untitled - Chronicis" 
                    : $"{newTitle} - Chronicis";
                await JSRuntime.InvokeVoidAsync("eval", $"document.title = '{EscapeForJs(pageTitle)}'");
                
                // Refresh tree first
                TreeState.RefreshTree();
                
                await Task.Delay(500);
                
                // Expand path and select the article
                TreeState.ExpandAndSelectArticle(_article.Id);
                
                // Update URL
                Navigation.NavigateTo($"/article/{newSlug}", replace: true);
            }

            Snackbar.Add("Article saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }

    // NEW: Slug creation helper
    private static string CreateSlug(string title)
    {
        if (string.IsNullOrEmpty(title))
            return "untitled";
        
        var slug = title.ToLowerInvariant();
        slug = slug.Replace(" ", "-");
        slug = new string(slug.Where(c => char.IsLetterOrDigit(c) || c == '-').ToArray());
        
        while (slug.Contains("--"))
            slug = slug.Replace("--", "-");
        
        slug = slug.Trim('-');
        
        return string.IsNullOrEmpty(slug) ? "untitled" : slug;
    }

    private async Task DeleteArticle()
    {
        if (_article == null) return;

        var confirmed = await JSRuntime.InvokeAsync<bool>(
            "confirm",
            $"Are you sure you want to delete '{_article.Title}'? This action cannot be undone."
        );

        if (!confirmed) return;

        try
        {
            await ArticleApi.DeleteArticleAsync(_article.Id);
            Snackbar.Add("Article deleted successfully", Severity.Success);
            TreeState.RefreshTree();
            _article = null;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateRootArticle()
    {
        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = "Untitled",
                Body = string.Empty,
                ParentId = null,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            TreeState.RefreshTree();
            Snackbar.Add("Article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private void ToggleMetadata()
    {
        _openMetadata = !_openMetadata;
    }

    [JSInvokable("HandleHashtagLinkRequest")]
    public static async Task HandleHashtagLinkRequest(string hashtagName)
    {
        var evt = new CustomEventArgs { HashtagName = hashtagName };
        OnHashtagLinkRequested?.Invoke(evt);
    }

    private static event Action<CustomEventArgs>? OnHashtagLinkRequested;

    private class CustomEventArgs
    {
        public string HashtagName { get; set; } = string.Empty;
    }

    protected override void OnInitialized()
    {
        OnHashtagLinkRequested += HandleHashtagLinkRequestInstance;
        base.OnInitialized();
    }

    private async void HandleHashtagLinkRequestInstance(CustomEventArgs args)
    {
        await InvokeAsync(async () =>
        {
            await OpenHashtagLinkDialog(args.HashtagName);
        });
    }

    private async Task OpenHashtagLinkDialog(string hashtagName)
    {
        var parameters = new DialogParameters
    {
        { "HashtagName", hashtagName }
    };

        var options = new DialogOptions
        {
            CloseButton = true,
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<HashtagLinkDialog>(
            "Link Hashtag to Article",
            parameters,
            options
        );

        var result = await dialog.Result;

        if (!result?.Canceled ?? true)
        {
            // Hashtag was linked, refresh editor
            if (_article != null && _editorInitialized)
            {
                await JSRuntime.InvokeVoidAsync("destroyTipTapEditor", $"tiptap-editor-{_article.Id}");
                _editorInitialized = false;
                await Task.Delay(100);
                await InitializeEditor();
            }

            StateHasChanged();
        }
    }

    public void Dispose()
    {
        TreeState.OnStateChanged -= OnTreeStateChanged;
        OnHashtagLinkRequested -= HandleHashtagLinkRequestInstance;
        _autoSaveTimer?.Dispose();
        _dotNetHelper?.Dispose();
    }
}
