@using MudBlazor.Charts
@inject IArticleApiService ArticleApi
@inject ITreeStateService TreeState
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@implements IDisposable

@if (_isLoading)
{
    <LoadingSkeleton />
}
else if (_article == null)
{
    <EmptyState 
        Icon="üìù"
        Title="No Article Selected"
        Message="Select an article from the tree to view and edit its content."
        ActionText="Create New Article"
        OnActionClick="CreateRootArticle" />
}
else
{
    <style>
        .metadata-drawer,
        .metadata-drawer .mud-drawer-content {
            background-color: transparent !important;
            border-right-color: transparent;
        }
            .metadata-drawer .mud-drawer-content {
                padding: 8px;
                background-color: var(--chronicis-soft-off-white) !important;
            }
            .metadata-drawer.mud-drawer-persistent {
                height:auto !important;
            }

        .mud-input.mud-input-underline:before,
        .mud-input.mud-input-underline:after,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):before,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):after {
            border-bottom: none !important;        
        }

        .mud-input,
        .chronicis-editor-content {
            border: solid 1px #c7c7c4;
            padding:8px;
            border-radius: 4px;
        }
    </style>

    <MudPaper Elevation="2" Class="chronicis-article-card chronicis-fade-in">

        <div class="mud-toolbar">
        <!-- Breadcrumbs -->
        @if (_breadcrumbs != null && _breadcrumbs.Any())
        {
            <MudBreadcrumbs Items="_breadcrumbs">
                <ItemTemplate Context="item">
                    <MudLink Href="@item.Href" Class="chronicis-breadcrumb-link">
                        @item.Text
                    </MudLink>
                </ItemTemplate>
            </MudBreadcrumbs>
        }
        <MudSpacer />
    <!-- Metadata Toggle Button -->
            <MudTooltip Text="Metadata">
                <MudIconButton Color="Color.Inherit"
                               OnClick="@ToggleMetadata"
                               Icon="@Icons.Material.Filled.ChromeReaderMode"
                               Class="mt-0"
                Edge="Edge.End">
                </MudIconButton>
            </MudTooltip>
        </div>

        <!-- Title (Always Editable) - NO AUTO-SAVE -->
        <MudTextField @ref="_titleField"
                      @bind-Value="_editTitle"
                      Variant="Variant.Text"
                      Placeholder="Untitled Article"
                      Class="chronicis-article-title mb-3"
                      Style="font-size: 2rem; font-family: var(--chronicis-font-heading);"
                      @onkeyup="@(() => OnTitleChanged())"
                      DisableUnderLine="true" />

        <!-- Divider -->
        <div class="chronicis-rune-divider mb-3"></div>

        <!-- TipTap Editor Container (from Phase 4) -->
        <div id="tiptap-editor-@_article.Id" class="chronicis-editor-container mb-4"></div>

        <!-- Save Status -->
        <div class="chronicis-flex-between mt-4">
            <div class="chronicis-save-status @_saveStatusClass">
                @if (_isSaving)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    <span>Saving...</span>
                }
                else if (_hasUnsavedChanges)
                {
                    <span>‚ö†Ô∏è Unsaved changes</span>
                }
                else
                {
                    <span>‚úì Saved @_lastSaveTime</span>
                }
            </div>

            <div class="chronicis-flex" style="gap: 8px;">
                <MudButton 
                    Variant="Variant.Filled" 
                    Color="Color.Primary"
                    OnClick="SaveArticle"
                    Disabled="_isSaving"
                    StartIcon="@Icons.Material.Filled.Save">
                    Save
                </MudButton>
                
                <MudButton 
                    Variant="Variant.Outlined" 
                    Color="Color.Error"
                    OnClick="DeleteArticle"
                    StartIcon="@Icons.Material.Filled.Delete">
                    Delete
                </MudButton>
            </div>
        </div>
    </MudPaper>
    <!-- Metadata -->
    <MudDrawer @bind-Open="@_openMetadata"
               Fixed="true"
               Anchor="Anchor.End"
               Elevation="9999"
               Variant="@DrawerVariant.Persistent"
               ClipMode="@DrawerClipMode.Always"
               Class="metadata-drawer">
        <MudDrawerHeader>
            <MudText Typo="Typo.h6">Metadata</MudText>
        </MudDrawerHeader>
        <MudDrawerContainer>
            <ul class="ml-3">
                @if (_article.CreatedDate != default)
                {
                    <li>‚Ä¢ Created @_article.CreatedDate.ToString("MMMM d, yyyy 'at' h:mm tt")</li>
                }
                @if (_article.ModifiedDate != null)
                {
                    <li>‚Ä¢ Modified @_article.ModifiedDate.Value.ToString("MMMM d, yyyy 'at' h:mm tt")</li>
                }
            </ul>
        </MudDrawerContainer>
    </MudDrawer>
}

@code {
    private ArticleDto? _article;
    private List<BreadcrumbItem>? _breadcrumbs;
    private string _editTitle = string.Empty;
    private string _editBody = string.Empty;
    private bool _isLoading = false;
    private bool _isSaving = false;
    private bool _hasUnsavedChanges = false;
    private bool _editorInitialized = false;
    private string _lastSaveTime = "just now";
    private Timer? _autoSaveTimer;
    private MudTextField<string>? _titleField;
    private DotNetObjectReference<ArticleDetail>? _dotNetHelper;
    private bool _openMetadata = false;

    private string _saveStatusClass => _isSaving ? "saving" : _hasUnsavedChanges ? "unsaved" : "saved";

    protected override async Task OnInitializedAsync()
    {
        TreeState.OnStateChanged += OnTreeStateChanged;
        _dotNetHelper = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // ONLY handle first render
        if (firstRender && TreeState.SelectedArticleId.HasValue)
        {
            await LoadArticleAsync(TreeState.SelectedArticleId.Value);
            StateHasChanged();
            await Task.Delay(100);
            await InitializeEditor();
        }
    }

    private async void OnTreeStateChanged()
    {
        await InvokeAsync(async () =>
        {
            if (_editorInitialized && _article != null)
            {
                await JSRuntime.InvokeVoidAsync("destroyTipTapEditor", $"tiptap-editor-{_article.Id}");
            }

            _editorInitialized = false;

            if (TreeState.SelectedArticleId.HasValue)
            {
                await LoadArticleAsync(TreeState.SelectedArticleId.Value);
            }
            else
            {
                _article = null;
            }

            StateHasChanged();
            await Task.Delay(100);
            await InitializeEditor();
        });
    }

    private async Task LoadArticleAsync(int articleId)
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            _article = await ArticleApi.GetArticleAsync(articleId);
            _editTitle = _article.Title ?? string.Empty;
            _editBody = _article.Body ?? string.Empty;
            _hasUnsavedChanges = false;
            await LoadBreadcrumbsAsync(articleId);

            // Focus title if it's empty (new article)
            if (string.IsNullOrEmpty(_editTitle))
            {
                await Task.Delay(100);
                _titleField?.FocusAsync().GetAwaiter().GetResult();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load article: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task LoadBreadcrumbsAsync(int articleId)
    {
        _breadcrumbs = new List<BreadcrumbItem>
        {
            new BreadcrumbItem("Home", href: "/"),
            new BreadcrumbItem(_article?.Title ?? "Article", href: null, disabled: true)
        };
    }

    private async Task InitializeEditor()
    {
        if (_article != null && !_editorInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync(
                    "initializeTipTapEditor",
                    $"tiptap-editor-{_article.Id}",
                    _editBody,
                    _dotNetHelper
                );
                _editorInitialized = true;
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to initialize editor: {ex.Message}", Severity.Warning);
            }
        }
    }

    [JSInvokable]
    public void OnEditorUpdate(string markdown)
    {
        _editBody = markdown;
        OnContentChanged();
    }

    // NEW: Title changes only mark as unsaved, no auto-save
    private void OnTitleChanged()
    {
        _hasUnsavedChanges = true;
        // No auto-save timer for title changes
    }

    // UPDATED: Only body content triggers auto-save
    private void OnContentChanged()
    {
        _hasUnsavedChanges = true;
        _autoSaveTimer?.Dispose();
        _autoSaveTimer = new Timer(async _ => await AutoSave(), null, 500, Timeout.Infinite);
    }

    private async Task AutoSave()
    {
        await InvokeAsync(async () =>
        {
            if (_hasUnsavedChanges && !_isSaving)
            {
                await SaveArticle();
            }
        });
    }

    // UPDATED: Save with title change detection and URL update
    private async Task SaveArticle()
    {
        if (_article == null || _isSaving) return;

        _isSaving = true;
        StateHasChanged();

        try
        {
            // Track if title changed
            var originalTitle = _article.Title;
            var newTitle = _editTitle?.Trim() ?? string.Empty;
            var titleChanged = originalTitle != newTitle;

            // Create update DTO from current state
            var updateDto = new ArticleUpdateDto
            {
                Title = newTitle,
                Body = _editBody,
                EffectiveDate = _article.EffectiveDate,
                IconEmoji = _article.IconEmoji
            };

            await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);

            // Update local article with changes
            _article.Title = newTitle;
            _article.Body = _editBody;
            _article.ModifiedDate = DateTime.Now;

            _hasUnsavedChanges = false;
            _lastSaveTime = "just now";

            // If title changed, update URL and refresh tree
            if (titleChanged)
            {
                var newSlug = CreateSlug(newTitle);
                
                // Refresh tree first
                TreeState.RefreshTree();
                
                await Task.Delay(500);
                
                // Expand path and select the article
                TreeState.ExpandAndSelectArticle(_article.Id);
                
                // Update URL
                Navigation.NavigateTo($"/article/{newSlug}", replace: true);
            }

            Snackbar.Add("Article saved successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }

    // NEW: Slug creation helper
    private static string CreateSlug(string title)
    {
        if (string.IsNullOrEmpty(title))
            return "untitled";
        
        var slug = title.ToLowerInvariant();
        slug = slug.Replace(" ", "-");
        slug = new string(slug.Where(c => char.IsLetterOrDigit(c) || c == '-').ToArray());
        
        while (slug.Contains("--"))
            slug = slug.Replace("--", "-");
        
        slug = slug.Trim('-');
        
        return string.IsNullOrEmpty(slug) ? "untitled" : slug;
    }

    private async Task DeleteArticle()
    {
        if (_article == null) return;

        var confirmed = await JSRuntime.InvokeAsync<bool>(
            "confirm",
            $"Are you sure you want to delete '{_article.Title}'? This action cannot be undone."
        );

        if (!confirmed) return;

        try
        {
            await ArticleApi.DeleteArticleAsync(_article.Id);
            Snackbar.Add("Article deleted successfully", Severity.Success);
            TreeState.RefreshTree();
            _article = null;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateRootArticle()
    {
        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = "Untitled",
                Body = string.Empty,
                ParentId = null,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            TreeState.RefreshTree();
            Snackbar.Add("Article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private void ToggleMetadata()
    {
        _openMetadata = !_openMetadata;
    }

    public void Dispose()
    {
        TreeState.OnStateChanged -= OnTreeStateChanged;
        _autoSaveTimer?.Dispose();
        _dotNetHelper?.Dispose();
    }
}
