@using Chronicis.Client.Components.Shared
@using Chronicis.Shared.Utilities
@using MudBlazor.Charts
@using Blazored.LocalStorage
@inject IArticleApiService ArticleApi
@inject ILinkApiService LinkApiService
@inject ITreeStateService TreeState
@inject IAppContextService AppContext
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@inject IDialogService DialogService
@inject ILocalStorageService LocalStorage
@inject ILogger<ArticleDetail> Logger
@inject IArticleCacheService ArticleCache

@implements IDisposable

@if (_isLoading)
{
    <LoadingSkeleton />
}
else if (_article == null)
{
    <EmptyState 
        Icon="üìù"
        Title="No Article Selected"
        Message="Select an article from the tree to view and edit its content."
        ActionText="Create New Article"
        OnActionClick="CreateRootArticle" />
}
else
{
    <style>
        .metadata-drawer,
        .metadata-drawer .mud-drawer-content {
            background-color: transparent !important;
            border-right-color: transparent;
        }
            .metadata-drawer .mud-drawer-content {
                padding: 8px;
                background-color: var(--chronicis-soft-off-white) !important;
            }
            .metadata-drawer.mud-drawer-persistent {
                height:auto !important;
            }
            .metadata-drawer p {
                font-size: 0.8rem;
            }

        /* Scrollable metadata drawer */
        .metadata-drawer-scrollable {
            height: calc(100vh - 180px);
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: 24px;
        }

        .mud-input.mud-input-underline:before,
        .mud-input.mud-input-underline:after,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):before,
        .mud-input.mud-input-underline:hover:not(.mud-disabled):after {
            border-bottom: none !important;        
        }

        .mud-input,
        .chronicis-editor-content {
            border: solid 1px #c7c7c4;
            border-radius: 4px;
        }

        .chronicis-article-title .mud-input {
            padding-left:8px;
        }
    </style>

    <MudPaper Elevation="2" Class="chronicis-article-card chronicis-fade-in">

        <div class="mud-toolbar">
        <!-- Breadcrumbs -->
        @if (_breadcrumbs != null && _breadcrumbs.Any())
        {
            <MudBreadcrumbs Items="_breadcrumbs">
                <ItemTemplate Context="item">
                    <MudLink Href="@item.Href" Class="chronicis-breadcrumb-link">
                        @item.Text
                    </MudLink>
                </ItemTemplate>
            </MudBreadcrumbs>
        }
        <MudSpacer />
    <!-- Metadata Toggle Button -->
            <MudTooltip Text="Metadata">
                <MudIconButton Color="Color.Inherit"
                               OnClick="@ToggleMetadata"
                               Icon="@Icons.Material.Filled.ChromeReaderMode"
                               Class="mt-0"
                Edge="Edge.End">
                </MudIconButton>
            </MudTooltip>
        </div>

        <!-- Title Row with Icon Picker -->
        <div class="d-flex align-center mb-3">
            <!-- Icon Picker Button -->
            <IconPickerButton 
                CurrentIcon="@_article.IconEmoji"
                OnIconChanged="OnIconChanged" />
            
            <!-- Title (Always Editable) - NO AUTO-SAVE -->
            <MudTextField @ref="_titleField"
                          @bind-Value="_editTitle"
                          Variant="Variant.Text"
                          Placeholder="Untitled Article"
                          Class="chronicis-article-title flex-grow-1"
                          Style="font-size: 2rem; font-family: var(--chronicis-font-heading);"
                          Immediate="true"
                          @onkeyup="@(() => OnTitleChanged())"
                          @onkeydown="@OnTitleKeyDown"
                          Underline="false"/>
        </div>

        <!-- Divider -->
        <div class="chronicis-rune-divider mb-3"></div>

        <!-- TipTap Editor Container (from Phase 4) -->
        <div id="tiptap-editor-@_article.Id" class="chronicis-editor-container mb-4"></div>

        <!-- AI Summary Section -->
        <AISummarySection ArticleId="@_article.Id"
                          IsExpanded="@_isSummaryExpanded"
                          IsExpandedChanged="@((expanded) => _isSummaryExpanded = expanded)" />

        <!-- Save Status -->
        <div class="chronicis-flex-between mt-4">
            <div class="chronicis-save-status @_saveStatusClass">
                @if (_isSaving)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    <span>Saving...</span>
                }
                else if (_hasUnsavedChanges)
                {
                    <span>‚ö†Ô∏è Unsaved changes</span>
                }
                else
                {
                    <span>‚úì Saved @_lastSaveTime</span>
                }
            </div>

            <div class="chronicis-flex" style="gap: 8px;">
                <MudButton 
                    Variant="Variant.Outlined" 
                    Color="Color.Secondary"
                    OnClick="AutoLinkArticle"
                    Disabled="_isSaving || _isAutoLinking"
                    StartIcon="@Icons.Material.Filled.AutoFixHigh">
                    @if (_isAutoLinking)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        <span>Scanning...</span>
                    }
                    else
                    {
                        <span>Auto-Link</span>
                    }
                </MudButton>
                
                <MudButton 
                    Variant="Variant.Filled" 
                    Color="Color.Primary"
                    OnClick="SaveArticle"
                    Disabled="_isSaving"
                    StartIcon="@Icons.Material.Filled.Save">
                    Save
                </MudButton>
                
                <MudButton 
                    Variant="Variant.Outlined" 
                    Color="Color.Error"
                    OnClick="DeleteArticle"
                    StartIcon="@Icons.Material.Filled.Delete">
                    Delete
                </MudButton>
            </div>
        </div>
    </MudPaper>
    <!-- Metadata Drawer -->
    <MudDrawer @bind-Open="@_openMetadata"
               Fixed="true"
               Anchor="Anchor.End"
               Elevation="9999"
               Variant="@DrawerVariant.Persistent"
               ClipMode="@DrawerClipMode.Always"
               Class="metadata-drawer">
        <MudDrawerHeader Class="backlinks-header">
            <MudText Typo="Typo.h6" Class="backlinks-title">
                <MudIcon Icon="@Icons.Material.Filled.IntegrationInstructions" Size="Size.Small" />
                Metadata
            </MudText>
        </MudDrawerHeader>
        <MudDrawerContainer Class="metadata-drawer-scrollable chronicis-scrollbar-light">
            <!-- Outgoing Links Panel -->
            <OutgoingLinksPanel @ref="_outgoingLinksPanel" ArticleId="@_article.Id" />
            
            <MudDivider Class="my-3" />
            
            <!-- Backlinks Panel -->
            <BacklinksPanel @ref="_backlinksPanel" ArticleId="@_article.Id" />
            
            <MudDivider Class="my-3" />
            
            <!-- Article Metadata -->
            <MudText Typo="Typo.subtitle2" Class="px-4 py-2" Style="color: var(--mud-palette-text-secondary);">Article Info</MudText>
            <MudList T="string">
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Article ID</MudText>
                        <MudText Typo="Typo.body2">@_article.Id</MudText>
                </MudListItem>
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">World ID</MudText>
                        <MudText Typo="Typo.body2">@_article.WorldId</MudText>
                </MudListItem>
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Campaign ID</MudText>
                        <MudText Typo="Typo.body2">@(_article.CampaignId?.ToString() ?? "None")</MudText>
                </MudListItem>
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Effective Date</MudText>
                        <MudText Typo="Typo.body2">
                            @_article.EffectiveDate.ToString("MMMM d, yyyy 'at' h:mm tt")
                        </MudText>
                </MudListItem>
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Created Date</MudText>
                        <MudText Typo="Typo.body2">
                            @_article.CreatedAt.ToString("MMMM d, yyyy 'at' h:mm tt")
                        </MudText>
                </MudListItem>
                <MudListItem>
                        <MudText Typo="Typo.subtitle1">Modified Date</MudText>
                        <MudText Typo="Typo.body2">
                            @_article.ModifiedAt?.ToString("MMMM d, yyyy 'at' h:mm tt")
                        </MudText>
                </MudListItem>
            </MudList>
        </MudDrawerContainer>
    </MudDrawer>

    <!-- Wiki Link Autocomplete -->
    @if (_showAutocomplete && _article != null)
    {
        <WikiLinkAutocomplete Suggestions="@_autocompleteSuggestions"
                              Loading="@_autocompleteLoading"
                              SelectedIndex="@_autocompleteSelectedIndex"
                              SelectedIndexChanged="OnAutocompleteIndexChanged"
                              OnSelect="OnAutocompleteSelect"
                              OnCreate="OnAutocompleteCreate"
                              Position="@_autocompletePosition"
                              Query="@_autocompleteQuery" />
    }
}

@code {
    private ArticleDto? _article;
    private List<BreadcrumbItem>? _breadcrumbs;
    private string _editTitle = string.Empty;
    private string _editBody = string.Empty;
    private bool _isLoading = false;
    private bool _isSaving = false;
    private bool _isAutoLinking = false;
    private bool _hasUnsavedChanges = false;
    private bool _editorInitialized = false;
    private string _lastSaveTime = "just now";
    private Timer? _autoSaveTimer;
    private MudTextField<string>? _titleField;
    private DotNetObjectReference<ArticleDetail>? _dotNetHelper;
    private bool _openMetadata = false;
    private bool _isSummaryExpanded = false;
    private bool _shouldFocusTitle = false;
    
    // Panel references for refresh
    private OutgoingLinksPanel? _outgoingLinksPanel;
    private BacklinksPanel? _backlinksPanel;
    
    // Autocomplete state
    private bool _showAutocomplete = false;
    private bool _autocompleteLoading = false;
    private List<LinkSuggestionDto> _autocompleteSuggestions = new();
    private int _autocompleteSelectedIndex = 0;
    private (double X, double Y) _autocompletePosition = (0, 0);
    private string _autocompleteQuery = string.Empty;
    
    private const string LastArticlePathKey = "chronicis_last_article_path";

    private string _saveStatusClass => _isSaving ? "saving" : _hasUnsavedChanges ? "unsaved" : "saved";

    protected override async Task OnInitializedAsync()
    {
        TreeState.OnStateChanged += OnTreeStateChanged;
        _dotNetHelper = DotNetObjectReference.Create(this);
        await Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // ONLY handle first render
        if (firstRender && TreeState.SelectedArticleId.HasValue)
        {
            await LoadArticleAsync(TreeState.SelectedArticleId.Value);
            StateHasChanged();
            await Task.Delay(100);
            await InitializeEditor();
        }

        // Focus title field if flagged (after component has rendered)
        if (_shouldFocusTitle && _titleField != null)
        {
            _shouldFocusTitle = false;
            await Task.Delay(100);
            try
            {
                await _titleField.FocusAsync();
                // Also try JS focus as backup
                await JSRuntime.InvokeVoidAsync("eval", 
                    "document.querySelector('.chronicis-article-title input')?.focus();");
            }
            catch { /* ignore focus errors */ }
        }
    }

    private async void OnTreeStateChanged()
    {
        await InvokeAsync(async () =>
        {
            if (_editorInitialized && _article != null)
            {
                await JSRuntime.InvokeVoidAsync("destroyTipTapEditor", $"tiptap-editor-{_article.Id}");
            }

            _editorInitialized = false;

            // Check if article is selected AND valid
            if (TreeState.SelectedArticleId.HasValue && TreeState.SelectedArticleId.Value != Guid.Empty)
            {
                await LoadArticleAsync(TreeState.SelectedArticleId.Value);
            }
            else
            {
                _article = null;

                // Reset page title to default
                await JSRuntime.InvokeVoidAsync("eval", "document.title = 'Chronicis'");
            }

            StateHasChanged();

            if (_article != null)
            {
                await Task.Delay(100);
                await InitializeEditor();
            }
        });
    }

    private async Task LoadArticleAsync(Guid articleId)
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            _article = await ArticleApi.GetArticleAsync(articleId);
            _editTitle = _article?.Title ?? string.Empty;
            _editBody = _article?.Body ?? string.Empty;
            _hasUnsavedChanges = false;

            // Cache the loaded article for tooltips/navigation
            if (_article != null)
            {
                ArticleCache.CacheArticle(_article);
            }

            LoadBreadcrumbs(articleId);

            // Update browser page title
            var pageTitle = string.IsNullOrEmpty(_article?.Title) 
                ? "Untitled - Chronicis" 
                : $"{_article.Title} - Chronicis";
            await JSRuntime.InvokeVoidAsync("eval", $"document.title = '{EscapeForJs(pageTitle)}'");

            // Save last visited article path to localStorage
            if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
            {
                var path = string.Join("/", _article.Breadcrumbs.Select(b => b.Slug));
                await LocalStorage.SetItemAsStringAsync(LastArticlePathKey, $"/article/{path}");
            }

            // Focus title if it's empty (new article) OR if ShouldFocusTitle flag is set
            if (string.IsNullOrEmpty(_editTitle) || TreeState.ShouldFocusTitle)
            {
                _shouldFocusTitle = true;
                TreeState.ShouldFocusTitle = false; // Clear the flag
                StateHasChanged(); // Trigger re-render so OnAfterRenderAsync runs
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load article: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    // Helper to escape strings for JavaScript
    private static string EscapeForJs(string text)
    {
        return text.Replace("'", "\\'").Replace("\n", "\\n").Replace("\r", "\\r");
    }

    private void LoadBreadcrumbs(Guid articleId)
    {
        _breadcrumbs = new List<BreadcrumbItem>
        {
            new BreadcrumbItem("Home", href: "/dashboard")
        };

        // Build hierarchical paths from breadcrumbs
        if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
        {
            for (int i = 0; i < _article.Breadcrumbs.Count; i++)
            {
                var crumb = _article.Breadcrumbs[i];
                var isLast = i == _article.Breadcrumbs.Count - 1;
                
                // Build path up to this breadcrumb
                var pathSegments = _article.Breadcrumbs
                    .Take(i + 1)
                    .Select(b => b.Slug);
                var path = string.Join("/", pathSegments);
                
                _breadcrumbs.Add(new BreadcrumbItem(
                    crumb.Title,
                    href: isLast ? null : $"/article/{path}",
                    disabled: isLast
                ));
            }
        }
    }

    private async Task InitializeEditor()
    {
        if (_article != null && !_editorInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync(
                    "initializeTipTapEditor",
                    $"tiptap-editor-{_article.Id}",
                    _editBody,
                    _dotNetHelper
                );
                
                // Initialize autocomplete
                await JSRuntime.InvokeVoidAsync(
                    "initializeWikiLinkAutocomplete",
                    $"tiptap-editor-{_article.Id}",
                    _dotNetHelper
                );
                
                _editorInitialized = true;
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to initialize editor: {ex.Message}", Severity.Warning);
            }
        }
    }

    [JSInvokable]
    public void OnEditorUpdate(string markdown)
    {
        _editBody = markdown;
        OnContentChanged();
    }

    // NEW: Title changes only mark as unsaved, no auto-save
    private void OnTitleChanged()
    {
        _hasUnsavedChanges = true;
        // No auto-save timer for title changes
    }

    // Handle icon changes - auto-save immediately
    private async Task OnIconChanged(string? newIcon)
    {
        if (_article == null || _isSaving) return;

        // Update local state
        _article.IconEmoji = newIcon;
        
        // Save immediately
        _isSaving = true;
        StateHasChanged();

        try
        {
            var updateDto = new ArticleUpdateDto
            {
                Title = _editTitle?.Trim() ?? string.Empty,
                Body = _editBody,
                EffectiveDate = _article.EffectiveDate,
                IconEmoji = newIcon
            };

            await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);
            _article.ModifiedAt = DateTime.Now;
            _lastSaveTime = "just now";

            // Refresh tree to show updated icon
            await TreeState.RefreshAsync();
            
            // Update tree node display
            TreeState.UpdateNodeDisplay(_article.Id, _editTitle ?? string.Empty, newIcon);

            var action = string.IsNullOrEmpty(newIcon) ? "removed" : "updated";
            Snackbar.Add($"Icon {action}", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save icon: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }

    // NEW: Handle Enter key in title field
    private async Task OnTitleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SaveArticle();
        }
    }

    // UPDATED: Only body content triggers auto-save
    private void OnContentChanged()
    {
        _hasUnsavedChanges = true;
        _autoSaveTimer?.Dispose();
        _autoSaveTimer = new Timer(async _ => await AutoSave(), null, 500, Timeout.Infinite);
    }

    private async Task AutoSave()
    {
        await InvokeAsync(async () =>
        {
            if (_hasUnsavedChanges && !_isSaving)
            {
                await SaveArticle();
            }
        });
    }

    // UPDATED: Save with title change detection and URL update
    private async Task SaveArticle()
    {
        if (_article == null || _isSaving) return;

        _isSaving = true;
        StateHasChanged();

        try
        {
            // Track if title changed
            var originalTitle = _article.Title;
            var newTitle = _editTitle?.Trim() ?? string.Empty;
            var titleChanged = originalTitle != newTitle;

            string? newSlug = null;
            
            // If title changed, ask if user wants to update slug
            if (titleChanged)
            {
                var suggestedSlug = SlugGenerator.GenerateSlug(newTitle);
                var currentSlug = _article.Slug;
                
                if (suggestedSlug != currentSlug)
                {
                    newSlug = suggestedSlug;
                }
            }

            // Create update DTO from current state
            var updateDto = new ArticleUpdateDto
            {
                Title = newTitle,
                Slug = newSlug, // Only set if user confirmed slug change
                Body = _editBody,
                EffectiveDate = _article.EffectiveDate,
                IconEmoji = _article.IconEmoji
            };

            await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);

            // Invalidate cache since article content changed (links may have changed)
            ArticleCache.InvalidateCache();

            // Update local article with changes
            _article.Title = newTitle;
            _article.Body = _editBody;
            _article.ModifiedAt = DateTime.Now;

            _hasUnsavedChanges = false;
            _lastSaveTime = "just now";

            // If slug actually changed, update URL and refresh tree
            if (newSlug != null)
            {
                // Update browser page title
                var pageTitle = string.IsNullOrEmpty(newTitle) 
                    ? "Untitled - Chronicis" 
                    : $"{newTitle} - Chronicis";
                await JSRuntime.InvokeVoidAsync("eval", $"document.title = '{EscapeForJs(pageTitle)}'");
                
                // Update tree node display and refresh
                TreeState.UpdateNodeDisplay(_article.Id, newTitle, _article.IconEmoji);
                
                // Expand path and select the article
                TreeState.ExpandPathToAndSelect(_article.Id);
                
                // Reload article to get updated breadcrumbs with new slug
                _article = await ArticleApi.GetArticleAsync(_article.Id);
                
                // Build full hierarchical path from breadcrumbs
                if (_article?.Breadcrumbs != null && _article.Breadcrumbs.Any())
                {
                    var path = string.Join("/", _article.Breadcrumbs.Select(b => b.Slug));
                    Navigation.NavigateTo($"/article/{path}", replace: true);
                }
            }
            else if (titleChanged)
            {
                // Title changed but slug didn't - still update browser title
                var pageTitle = string.IsNullOrEmpty(newTitle) 
                    ? "Untitled - Chronicis" 
                    : $"{newTitle} - Chronicis";
                await JSRuntime.InvokeVoidAsync("eval", $"document.title = '{EscapeForJs(pageTitle)}'");
                
                // Update tree node display
                TreeState.UpdateNodeDisplay(_article.Id, newTitle, _article.IconEmoji);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
            
            // Refresh link panels after save (links may have changed)
            if (_outgoingLinksPanel != null)
            {
                await _outgoingLinksPanel.RefreshAsync();
            }
        }
    }

    private async Task DeleteArticle()
    {
        if (_article == null) return;

        // Build confirmation message with child warning if applicable
        var message = $"Are you sure you want to delete '{_article.Title}'?";
        
        if (_article.ChildCount > 0)
        {
            var childText = _article.ChildCount == 1 ? "1 child article" : $"{_article.ChildCount} child articles";
            message = $"Are you sure you want to delete '{_article.Title}'?\n\n‚ö†Ô∏è WARNING: This will also delete {childText} and all their descendants.";
        }
        
        message += "\n\nThis action cannot be undone.";

        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", message);

        if (!confirmed) return;

        try
        {
            await ArticleApi.DeleteArticleAsync(_article.Id);
            
            // Invalidate cache since article structure changed
            ArticleCache.InvalidateCache();
            
            Snackbar.Add("Article deleted successfully", Severity.Success);
            await TreeState.RefreshAsync();
            _article = null;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    private async Task AutoLinkArticle()
    {
        if (_article == null || _isAutoLinking) return;

        _isAutoLinking = true;
        StateHasChanged();

        try
        {
            // Call the auto-link API with current editor content
            var result = await LinkApiService.AutoLinkAsync(_article.Id, _editBody);

            if (result == null)
            {
                Snackbar.Add("Failed to scan for links", Severity.Error);
                return;
            }

            if (result.LinksFound == 0)
            {
                Snackbar.Add("No linkable content found", Severity.Info);
                return;
            }

            // Build confirmation message with match details
            var matchList = string.Join("\n", result.Matches.Select(m => $"‚Ä¢ \"{m.MatchedText}\" ‚Üí {m.ArticleTitle}"));
            var message = $"Found {result.LinksFound} potential link(s):\n\n{matchList}\n\nApply these links?";

            var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", message);

            if (!confirmed) return;

            // Update the editor with the modified body
            _editBody = result.ModifiedBody;
            
            // Update TipTap editor content
            await JSRuntime.InvokeVoidAsync(
                "setTipTapContent",
                $"tiptap-editor-{_article.Id}",
                result.ModifiedBody
            );

            // Mark as changed and save
            _hasUnsavedChanges = true;
            await SaveArticle();

            Snackbar.Add($"Added {result.LinksFound} link(s)", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error auto-linking article {ArticleId}", _article.Id);
            Snackbar.Add($"Failed to auto-link: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isAutoLinking = false;
            StateHasChanged();
        }
    }

    private async Task CreateRootArticle()
    {
        try
        {
            var worldId = AppContext.CurrentWorldId;
            if (!worldId.HasValue || worldId == Guid.Empty)
            {
                Snackbar.Add("Please select a World first", Severity.Warning);
                return;
            }

            var createDto = new ArticleCreateDto
            {
                Title = "Untitled",
                Body = string.Empty,
                ParentId = null,
                EffectiveDate = DateTime.Now,
                WorldId = worldId.Value
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            await TreeState.RefreshAsync();
            Snackbar.Add("Article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private void ToggleMetadata()
    {
        _openMetadata = !_openMetadata;
    }

    [JSInvokable("HandleCtrlN")]
    public static Task HandleCtrlN()
    {
        OnCtrlNPressed?.Invoke();
        return Task.CompletedTask;
    }

    private static event Action? OnCtrlNPressed;

    protected override void OnInitialized()
    {
        OnCtrlNPressed += HandleCtrlNInstance;
        base.OnInitialized();
    }

    private async void HandleCtrlNInstance()
    {
        await InvokeAsync(async () =>
        {
            await CreateSiblingArticle();
        });
    }

    private async Task CreateSiblingArticle()
    {
        if (_article == null) return;

        try
        {
            // Create sibling = same parent as current article
            var createDto = new ArticleCreateDto
            {
                Title = string.Empty,
                Body = string.Empty,
                ParentId = _article.ParentId, // Same parent = sibling
                EffectiveDate = DateTime.Now,
                WorldId = _article.WorldId,
                CampaignId = _article.CampaignId
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            
            // Refresh tree to show new article
            await TreeState.RefreshAsync();
            
            // Select and navigate to the new article
            TreeState.ExpandPathToAndSelect(created.Id);
            
            // Navigate to the new article
            if (created.Breadcrumbs != null && created.Breadcrumbs.Any())
            {
                var path = string.Join("/", created.Breadcrumbs.Select(b => b.Slug));
                Navigation.NavigateTo($"/article/{path}");
            }
            else
            {
                Navigation.NavigateTo($"/article/{created.Slug}");
            }

            Snackbar.Add("New article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    public void Dispose()
    {
        TreeState.OnStateChanged -= OnTreeStateChanged;
        OnCtrlNPressed -= HandleCtrlNInstance;
        _autoSaveTimer?.Dispose();
        _dotNetHelper?.Dispose();
    }

    // ============================================
    // WIKI LINK AUTOCOMPLETE
    // ============================================

    [JSInvokable]
    public async Task OnAutocompleteTriggered(string query, double x, double y)
    {
        _autocompletePosition = (x, y);
        _autocompleteQuery = query;
        _showAutocomplete = true;
        _autocompleteSelectedIndex = 0;
        
        if (query.Length < 3)
        {
            _autocompleteSuggestions = new List<LinkSuggestionDto>();
            StateHasChanged();
            return;
        }

        _autocompleteLoading = true;
        StateHasChanged();

        try
        {
            var worldId = AppContext.CurrentWorldId ?? _article?.WorldId ?? Guid.Empty;
            Logger.LogInformation("Autocomplete triggered: query={Query}, worldId={WorldId}, article.WorldId={ArticleWorldId}", 
                query, worldId, _article?.WorldId);
            
            _autocompleteSuggestions = await LinkApiService.GetSuggestionsAsync(worldId, query);
            
            Logger.LogInformation("Autocomplete results: {Count} suggestions", _autocompleteSuggestions.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting autocomplete suggestions");
            _autocompleteSuggestions = new List<LinkSuggestionDto>();
        }
        finally
        {
            _autocompleteLoading = false;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public Task OnAutocompleteHidden()
    {
        _showAutocomplete = false;
        _autocompleteSuggestions = new List<LinkSuggestionDto>();
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task OnAutocompleteIndexChanged(int index)
    {
        _autocompleteSelectedIndex = index;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task OnAutocompleteSelect(LinkSuggestionDto suggestion)
    {
        if (_article == null) return;

        try
        {
            Logger.LogInformation("OnAutocompleteSelect called: ArticleId={ArticleId}, Title={Title}", 
                suggestion.ArticleId, suggestion.Title);
            
            // Insert the wiki link via JavaScript
            await JSRuntime.InvokeVoidAsync(
                "insertWikiLink",
                $"tiptap-editor-{_article.Id}",
                suggestion.ArticleId.ToString(),
                suggestion.Title
            );

            Logger.LogInformation("insertWikiLink JavaScript call completed");

            // Hide autocomplete
            _showAutocomplete = false;
            _autocompleteSuggestions = new List<LinkSuggestionDto>();
            StateHasChanged();

            // Save immediately to prevent race condition when clicking the link
            await Task.Delay(50); // Small delay to let editor update _editBody
            await SaveArticle();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error inserting wiki link");
            Snackbar.Add("Failed to insert link", Severity.Error);
        }
    }

    [JSInvokable]
    public Task OnAutocompleteArrowDown()
    {
        if (_autocompleteSuggestions.Any())
        {
            _autocompleteSelectedIndex = (_autocompleteSelectedIndex + 1) % _autocompleteSuggestions.Count;
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnAutocompleteArrowUp()
    {
        if (_autocompleteSuggestions.Any())
        {
            _autocompleteSelectedIndex = (_autocompleteSelectedIndex - 1 + _autocompleteSuggestions.Count) % _autocompleteSuggestions.Count;
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnAutocompleteEnter()
    {
        if (_autocompleteSuggestions.Any() && _autocompleteSelectedIndex < _autocompleteSuggestions.Count)
        {
            await OnAutocompleteSelect(_autocompleteSuggestions[_autocompleteSelectedIndex]);
        }
    }

    private async Task OnAutocompleteCreate(string articleName)
    {
        if (_article == null || string.IsNullOrWhiteSpace(articleName)) return;

        try
        {
            Logger.LogInformation("Creating new article from autocomplete: {Name}", articleName);

            Guid worldId = AppContext.CurrentWorldId.HasValue 
                ? AppContext.CurrentWorldId.Value 
                : _article!.WorldId.HasValue ? _article.WorldId.Value : Guid.Empty;
            
            // Find the Wiki folder for this world
            Guid? wikiParentId = await FindWikiFolderAsync(worldId);
            
            if (wikiParentId == null)
            {
                Logger.LogWarning("No Wiki folder found for world {WorldId}, creating at world root", worldId);
            }

            var createDto = new ArticleCreateDto
            {
                Title = articleName,
                Body = string.Empty,
                ParentId = wikiParentId,
                EffectiveDate = DateTime.Now,
                WorldId = worldId
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            
            Logger.LogInformation("Created article {Id} with title {Title} under parent {ParentId}", 
                created.Id, created.Title, wikiParentId);

            // Insert the wiki link to the newly created article
            await JSRuntime.InvokeVoidAsync(
                "insertWikiLink",
                $"tiptap-editor-{_article.Id}",
                created.Id.ToString(),
                created.Title
            );

            // Hide autocomplete
            _showAutocomplete = false;
            _autocompleteSuggestions = new List<LinkSuggestionDto>();
            StateHasChanged();

            // Save immediately
            await Task.Delay(50);
            await SaveArticle();

            // Refresh tree to show new article
            await TreeState.RefreshAsync();

            Snackbar.Add($"Created and linked '{articleName}'", Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating article from autocomplete");
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private async Task<Guid?> FindWikiFolderAsync(Guid worldId)
    {
        try
        {
            // The Wiki folder is typically a child of the World article
            // First, get root articles for this world (which should include the World itself)
            var rootArticles = await ArticleApi.GetRootArticlesAsync(worldId);
            
            // The root article for a world is usually the world itself
            // Get children of the first root article (the world)
            if (rootArticles.Any())
            {
                var worldArticle = rootArticles.First();
                var worldChildren = await ArticleApi.GetChildrenAsync(worldArticle.Id);
                
                // Look for an article named "Wiki" (case-insensitive)
                var wikiFolder = worldChildren.FirstOrDefault(a => 
                    a.Title.Equals("Wiki", StringComparison.OrdinalIgnoreCase));
                
                if (wikiFolder != null)
                {
                    Logger.LogInformation("Found Wiki folder {WikiId} under world {WorldId}", wikiFolder.Id, worldId);
                    return wikiFolder.Id;
                }
            }
            
            // Fallback: check if Wiki is at root level
            var rootWiki = rootArticles.FirstOrDefault(a => 
                a.Title.Equals("Wiki", StringComparison.OrdinalIgnoreCase));
            
            if (rootWiki != null)
            {
                Logger.LogInformation("Found Wiki folder {WikiId} at root level", rootWiki.Id);
                return rootWiki.Id;
            }
            
            Logger.LogWarning("No Wiki folder found for world {WorldId}", worldId);
            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error finding Wiki folder for world {WorldId}", worldId);
            return null;
        }
    }

    [JSInvokable]
    public async Task OnWikiLinkClicked(string targetArticleId)
    {
        try
        {
            if (!Guid.TryParse(targetArticleId, out var articleId))
            {
                Logger.LogWarning("Invalid article ID clicked: {ArticleId}", targetArticleId);
                return;
            }

            // Use cache service to get navigation path
            var path = await ArticleCache.GetNavigationPathAsync(articleId);
            
            if (!string.IsNullOrEmpty(path))
            {
                Navigation.NavigateTo($"/article/{path}");
            }
            else
            {
                Snackbar.Add("Article not found", Severity.Warning);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error navigating to wiki link: {ArticleId}", targetArticleId);
            Snackbar.Add("Failed to navigate to article", Severity.Error);
        }
    }

    [JSInvokable]
    public async Task<string?> GetArticlePath(string targetArticleId)
    {
        try
        {
            if (!Guid.TryParse(targetArticleId, out var articleId))
            {
                return null;
            }

            // Use cache service to get the display path
            return await ArticleCache.GetArticlePathAsync(articleId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting article path: {ArticleId}", targetArticleId);
            return null;
        }
    }
}
