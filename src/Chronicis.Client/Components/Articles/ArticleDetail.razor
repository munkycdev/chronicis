@using Chronicis.Shared.DTOs
@using Chronicis.Shared.Models
@using Chronicis.Client.Services
@using Microsoft.JSInterop
@inject ArticleApiService ArticleApi
@inject TreeStateService TreeState
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ILogger<ArticleDetail> Logger
@inject IJSRuntime JSRuntime
@implements IDisposable

<MudPaper Elevation="0" Class="article-detail-container">
    @if (_isLoading)
    {
        <MudProgressLinear Indeterminate="true" />
        <MudSkeleton SkeletonType="SkeletonType.Text" Height="60px" Class="mt-4" />
        <MudSkeleton SkeletonType="SkeletonType.Text" Height="40px" Class="mt-2" />
        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="200px" Class="mt-4" />
    }
    else if (_error != null)
    {
        <MudAlert Severity="Severity.Error">@_error</MudAlert>
    }
    else if (_article == null)
    {
        <MudText Typo="Typo.h5" Class="mb-4">Welcome to Chronicis</MudText>
        <MudText Typo="Typo.body1" Class="mb-2">
            Select an article from the navigation tree to view its details.
        </MudText>
        <MudText Typo="Typo.body2" Color="Color.Default">
            Or create a new article to start building your campaign knowledge base.
        </MudText>
    }
    else
    {
        @* Breadcrumb Navigation *@
        <MudBreadcrumbs Items="_breadcrumbItems" Class="mb-4">
            <ItemTemplate Context="item">
                <MudLink Href="#" OnClick="@(() => NavigateToBreadcrumb(item))">
                    @item.Text
                </MudLink>
            </ItemTemplate>
        </MudBreadcrumbs>

        @* Article Title - Always Editable *@
        <MudTextField @bind-Value="_editTitle"
                      Variant="Variant.Text"
                      Margin="Margin.Dense"
                      Immediate="true"
                      Placeholder="Article Title"
                      Class="article-title-input mb-2"
                      OnKeyUp="OnTitleChanged"
                      Style="font-size: 2.5rem; font-weight: 500;" />

        @* Metadata & Save Status *@
        <div class="d-flex justify-space-between align-center mb-4">
            <MudText Typo="Typo.body2" Color="Color.Default">
                Created: @_article.CreatedDate.ToLocalTime().ToString("MMM dd, yyyy 'at' h:mm tt")
                @if (_article.ModifiedDate.HasValue)
                {
                    <span> â€¢ Modified: @_article.ModifiedDate.Value.ToLocalTime().ToString("MMM dd, yyyy 'at' h:mm tt")</span>
                }
            </MudText>

            @* Save Status Indicator *@
            <MudText Typo="Typo.caption" Color="@GetSaveStatusColor()" Class="save-status">
                @_saveStatus
            </MudText>
        </div>

        @* TipTap Editor Container *@
        <MudDivider Class="mb-4" />

        <div id="tiptap-editor-@_article.Id" class="tiptap-editor-container mb-4"></div>

        @* Action Buttons *@
        <div class="d-flex justify-end gap-2 mt-4">
            <MudButton Variant="Variant.Outlined"
                       Color="Color.Error"
                       StartIcon="@Icons.Material.Filled.Delete"
                       OnClick="OnDelete"
                       Disabled="_isSaving">
                Delete
            </MudButton>
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Material.Filled.Save"
                       OnClick="SaveNow"
                       Disabled="_isSaving || !_hasUnsavedChanges">
                @(_isSaving ? "Saving..." : "Save")
            </MudButton>
        </div>
    }
</MudPaper>

@code {
    private ArticleDetailDto? _article;
    private List<BreadcrumbItem> _breadcrumbItems = new();
    private bool _isLoading;
    private string? _error;

    // Editing state
    private string _editTitle = string.Empty;
    private string _editBody = string.Empty;
    private bool _hasUnsavedChanges = false;
    private bool _isSaving = false;
    private string _saveStatus = string.Empty;
    private System.Threading.Timer? _autoSaveTimer;
    private DotNetObjectReference<ArticleDetail>? _dotNetHelper;
    private bool _editorInitialized = false;

    protected override void OnInitialized()
    {
        TreeState.OnStateChanged += OnTreeStateChanged;
        _dotNetHelper = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && TreeState.SelectedArticle != null)
        {
            await LoadArticleAsync(TreeState.SelectedArticle.Id);
            StateHasChanged();
            await Task.Delay(100);
            await InitializeEditor();
        }

        // Don't auto-initialize on subsequent renders - we handle it manually in OnTreeStateChanged
    }

    private async Task InitializeEditor()
    {
        if (_article == null || _editorInitialized) return;

        var editorId = $"tiptap-editor-{_article.Id}";
        Logger.LogInformation("Attempting to initialize editor: {EditorId}", editorId);

        try
        {
            await JSRuntime.InvokeVoidAsync("initTipTapEditor",
                editorId,
                _editBody,
                _dotNetHelper);
            _editorInitialized = true;
            Logger.LogInformation("Editor initialized successfully: {EditorId}", editorId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize TipTap editor: {EditorId}", editorId);
            Snackbar.Add("Failed to initialize editor", Severity.Error);
        }
    }

    [JSInvokable]
    public void OnEditorUpdate(string markdown)
    {
        _editBody = markdown;
        OnContentChanged();
    }

    private async void OnTreeStateChanged()
    {
        await InvokeAsync(async () =>
        {
            if (TreeState.SelectedArticle != null)
            {
                if (_article == null || _article.Id != TreeState.SelectedArticle.Id)
                {
                    var newArticleId = TreeState.SelectedArticle.Id;
                    Logger.LogInformation("Switching to article: {ArticleId}", newArticleId);

                    // Cleanup old editor
                    if (_editorInitialized && _article != null)
                    {
                        try
                        {
                            await JSRuntime.InvokeVoidAsync("destroyTipTapEditor", $"tiptap-editor-{_article.Id}");
                            Logger.LogInformation("Destroyed old editor: tiptap-editor-{ArticleId}", _article.Id);
                        }
                        catch { }
                    }

                    _editorInitialized = false;

                    // Wait for LoadArticleAsync to FULLY complete
                    await LoadArticleAsync(newArticleId);

                    // NOW _article has the new data
                    Logger.LogInformation("Article loaded, _article.Id is now: {ArticleId}", _article?.Id);

                    // Force re-render to create new DOM container
                    StateHasChanged();

                    // Wait for DOM to update
                    await Task.Delay(100);

                    // Initialize editor with NEW article
                    Logger.LogInformation("About to initialize editor for article: {ArticleId}", _article?.Id);
                    await InitializeEditor();
                }
                else
                {
                    StateHasChanged();
                }
            }
            else
            {
                _article = null;
                _editorInitialized = false;
                StateHasChanged();
            }
        });
    }

    private async Task LoadArticleAsync(int articleId)
    {
        try
        {
            _autoSaveTimer?.Dispose();

            _isLoading = true;
            _error = null;
            _hasUnsavedChanges = false;
            StateHasChanged();

            _article = await ArticleApi.GetArticleDetailAsync(articleId);

            if (_article != null)
            {
                _editTitle = _article.Title;
                _editBody = _article.Body ?? string.Empty;
                _saveStatus = string.Empty;

                BuildBreadcrumbs();
            }
            else
            {
                _error = "Article not found.";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load article {ArticleId}", articleId);
            _error = "Failed to load article. Please try again.";
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private void BuildBreadcrumbs()
    {
        _breadcrumbItems = _article?.Breadcrumbs
            .Select(b => new BreadcrumbItem(b.Title, null, false, b.Id.ToString()))
            .ToList() ?? new();
    }

    private void NavigateToBreadcrumb(BreadcrumbItem item)
    {
        if (int.TryParse(item.Href, out var articleId))
        {
            var articleToSelect = FindArticleInTree(TreeState.RootItems, articleId);
            if (articleToSelect != null)
            {
                TreeState.SelectArticle(articleToSelect);
            }
        }
    }

    private ViewModels.ArticleTreeItemViewModel? FindArticleInTree(List<ViewModels.ArticleTreeItemViewModel> items, int id)
    {
        foreach (var item in items)
        {
            if (item.Id == id)
                return item;

            var found = FindArticleInTree(item.Children, id);
            if (found != null)
                return found;
        }
        return null;
    }

    private void OnTitleChanged()
    {
        OnContentChanged();
    }

    private void OnContentChanged()
    {
        var titleChanged = _editTitle != _article?.Title;
        var bodyChanged = _editBody != (_article?.Body ?? string.Empty);

        _hasUnsavedChanges = titleChanged || bodyChanged;

        if (_hasUnsavedChanges)
        {
            _saveStatus = "Unsaved changes";

            _autoSaveTimer?.Dispose();
            _autoSaveTimer = new System.Threading.Timer(async _ => await AutoSave(), null, 500, Timeout.Infinite);
        }

        StateHasChanged();
    }

    private async Task AutoSave()
    {
        if (_hasUnsavedChanges && !_isSaving && _article != null)
        {
            await InvokeAsync(async () =>
            {
                await SaveArticle();
            });
        }
    }

    private async Task SaveNow()
    {
        if (_article != null)
        {
            // Get current markdown from TipTap editor
            if (_editorInitialized)
            {
                try
                {
                    var markdown = await JSRuntime.InvokeAsync<string>("getTipTapMarkdown", $"tiptap-editor-{_article.Id}");
                    _editBody = markdown ?? _editBody;
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to get editor content");
                }
            }
            await SaveArticle();
        }
    }

    private async Task SaveArticle()
    {
        if (_article == null || _isSaving) return;

        try
        {
            _isSaving = true;
            _saveStatus = "Saving...";
            StateHasChanged();

            var updateDto = new ArticleUpdateDto
            {
                Title = _editTitle.Trim(),
                Body = _editBody
            };

            var updated = await ArticleApi.UpdateArticleAsync(_article.Id, updateDto);

            var titleChanged = _article.Title != updated.Title;
            _article.Title = updated.Title;
            _article.Body = updated.Body;
            _article.ModifiedDate = updated.ModifiedDate;

            _hasUnsavedChanges = false;
            _saveStatus = $"Saved {GetTimeAgo(DateTime.Now)}";

            await TreeState.UpdateArticleAsync(updated);

            if (titleChanged)
            {
                await ReloadBreadcrumbs();
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save article {ArticleId}", _article.Id);
            _saveStatus = "Error saving";
            Snackbar.Add("Failed to save article", Severity.Error);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }

    private async Task ReloadBreadcrumbs()
    {
        if (_article == null) return;

        try
        {
            var refreshed = await ArticleApi.GetArticleDetailAsync(_article.Id);
            if (refreshed != null)
            {
                _article.Breadcrumbs = refreshed.Breadcrumbs;
                BuildBreadcrumbs();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to reload breadcrumbs for article {ArticleId}", _article.Id);
        }
    }

    private async Task OnDelete()
    {
        if (_article == null) return;

        var confirmed = await DialogService.ShowMessageBox(
            "Delete Article",
            $"Are you sure you want to delete '{_article.Title}'? This action cannot be undone.",
            yesText: "Delete",
            cancelText: "Cancel");

        if (confirmed == true)
        {
            try
            {
                // Cleanup editor first
                if (_editorInitialized)
                {
                    try
                    {
                        await JSRuntime.InvokeVoidAsync("destroyTipTapEditor", $"tiptap-editor-{_article.Id}");
                    }
                    catch { }
                }

                await ArticleApi.DeleteArticleAsync(_article.Id);
                await TreeState.RemoveArticleAsync(_article.Id);
                Snackbar.Add("Article deleted successfully", Severity.Success);

                _article = null;
                _editorInitialized = false;
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to delete article {ArticleId}", _article.Id);
                Snackbar.Add("Failed to delete article", Severity.Error);
            }
        }
    }

    private Color GetSaveStatusColor()
    {
        if (_saveStatus.StartsWith("Error")) return Color.Error;
        if (_saveStatus.StartsWith("Saving")) return Color.Info;
        if (_saveStatus.StartsWith("Saved")) return Color.Success;
        if (_saveStatus.StartsWith("Unsaved")) return Color.Warning;
        return Color.Default;
    }

    private string GetTimeAgo(DateTime time)
    {
        return "just now";
    }

    public void Dispose()
    {
        TreeState.OnStateChanged -= OnTreeStateChanged;
        _autoSaveTimer?.Dispose();
        _dotNetHelper?.Dispose();

        // Cleanup TipTap editor
        if (_article != null && _editorInitialized)
        {
            try
            {
                JSRuntime.InvokeVoidAsync("destroyTipTapEditor", $"tiptap-editor-{_article.Id}");
            }
            catch { }
        }
    }
}
