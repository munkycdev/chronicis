@inject ITreeStateService TreeState
@inject IArticleApiService ArticleApi
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="chronicis-nav-menu">
    @if (_isLoading)
    {
        <div class="pa-4">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
            <MudText Typo="Typo.body2" Class="ml-2" Style="display: inline;">
                Loading articles...
            </MudText>
        </div>
    }
    else if (_rootArticles == null || !_rootArticles.Any())
    {
        <div class="pa-4 text-center">
            <div style="opacity: 0.5; font-size: 3rem;">ðŸ“š</div>
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mt-2 mb-3">
                No articles yet
            </MudText>
            <MudButton 
                Variant="Variant.Text" 
                Color="Color.Primary"
                Size="Size.Small"
                StartIcon="@Icons.Material.Filled.Add"
                OnClick="CreateRootArticle">
                Create First Article
            </MudButton>
        </div>
    }
    else
    {
        <MudNavMenu Class="chronicis-nav-menu-items">
            @foreach (var article in _rootArticles)
            {
                @RenderArticleNavItem(article)
            }
        </MudNavMenu>
    }
</div>

@code {
    private RenderFragment RenderArticleNavItem(ArticleTreeNode node) => __builder =>
    {
        <div class="chronicis-nav-item-container"
             @onmouseenter="@(() => node.IsHovered = true)"
             @onmouseleave="@(() => node.IsHovered = false)">

            @if (node.HasChildren)
            {
                // Article with children - use MudNavGroup
                <div class="chronicis-nav-group-wrapper">
                    <MudNavGroup Title="@node.Title"
                                 Icon="@GetNodeIcon(node)"
                                 IconColor="Color.Primary"
                                 Expanded="@node.IsExpanded"
                                 ExpandedChanged="@(async (expanded) => await OnExpandedChanged(node, expanded))"
                                 Class="@GetNavItemClass(node)"
                                 ExpandIcon="@Icons.Material.Filled.ExpandMore">
                        <!-- ADD THIS -->

                        <ChildContent>
                            @if (node.Children != null)
                            {
                                @foreach (var child in node.Children)
                                {
                                    @RenderArticleNavItem(child)
                                }
                            }
                        </ChildContent>
                    </MudNavGroup>

                    <!-- Clickable overlay on title to select article -->
                    <div class="chronicis-nav-group-click-handler"
                         @onclick="@(() => SelectArticle(node))"
                         @onclick:stopPropagation="true">
                    </div>
                </div>
            }
            else
            {
                // Leaf article - use MudNavLink
                <MudNavLink OnClick="@(() => SelectArticle(node))"
                            Icon="@GetNodeIcon(node)"
                            IconColor="Color.Primary"
                            Class="@GetNavItemClass(node)">

                    <div class="d-flex align-center justify-space-between" style="width: 100%;">
                        <span>@node.Title</span>
                        @if (node.IsHovered)
                        {
                            <MudMenu AnchorOrigin="Origin.BottomRight"
                                     TransformOrigin="Origin.TopRight"
                                     Dense="true">
                                <ActivatorContent>
                                    <MudIconButton Icon="@Icons.Material.Filled.MoreVert"
                                                   Size="Size.Small"
                                                   Class="chronicis-nav-item-menu"
                                                   @onclick:stopPropagation="true" />
                                </ActivatorContent>
                                <ChildContent>
                                    <MudMenuItem Icon="@Icons.Material.Filled.Add"
                                                 OnClick="@(() => CreateChildArticle(node))">
                                        Add Child
                                    </MudMenuItem>
                                    <MudMenuItem Icon="@Icons.Material.Filled.Delete"
                                                 OnClick="@(() => DeleteArticle(node))">
                                        Delete
                                    </MudMenuItem>
                                </ChildContent>
                            </MudMenu>
                        }
                    </div>
                </MudNavLink>
            }
        </div>
    };
}

@code {
    private List<ArticleTreeNode>? _rootArticles;
    private ArticleTreeNode? _selectedNode;
    private bool _isLoading = true;

    protected override async Task OnInitializedAsync()
    {
        await LoadRootArticles();
        TreeState.OnRefreshRequested += OnRefreshRequested;
    }

    private async Task LoadRootArticles()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            var articles = await ArticleApi.GetRootArticlesAsync();
            _rootArticles = articles.Select(a => new ArticleTreeNode(a)).ToList();

            foreach (var article in _rootArticles)
            {
                Console.WriteLine($"Article: {article.Title}, HasChildren: {article.HasChildren}, ChildCount: {article.Article.ChildCount}");
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load articles: {ex.Message}", Severity.Error);
            _rootArticles = new List<ArticleTreeNode>();
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async void OnRefreshRequested()
    {
        await InvokeAsync(async () =>
        {
            await LoadRootArticles();
            StateHasChanged();
        });
    }

    private void SelectArticle(ArticleTreeNode node)
    {
        _selectedNode = node;
        TreeState.SelectArticle(node.Article.Id);
        StateHasChanged();
    }

    private string GetNavItemClass(ArticleTreeNode node)
    {
        return _selectedNode?.Article.Id == node.Article.Id 
            ? "chronicis-nav-item-selected" 
            : "chronicis-nav-item";
    }

    private string GetNodeIcon(ArticleTreeNode node)
    {
        if (!string.IsNullOrEmpty(node.IconEmoji))
        {
            return node.IconEmoji;
        }
        
        return node.HasChildren 
            ? Icons.Material.Filled.Folder 
            : Icons.Material.Filled.Description;
    }

    private async Task OnExpandedChanged(ArticleTreeNode node, bool expanded)
    {
        node.IsExpanded = expanded;
        
        if (expanded && (node.Children == null || !node.Children.Any()))
        {
            await LoadChildrenForNode(node);
        }
        
        StateHasChanged();
    }

    private async Task CreateRootArticle()
    {
        try
        {
            var createDto = new ArticleCreateDto  // Changed
            {
                Title = "Untitled",
                Body = string.Empty,
                ParentId = null,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            await LoadRootArticles();
            // Remove TreeState.SelectArticle(created) - wrong type
            Snackbar.Add("Article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateChildArticle(ArticleTreeNode parent)
    {
        try
        {
            var createDto = new ArticleCreateDto  // Changed
            {
                Title = "Untitled",
                Body = string.Empty,
                ParentId = parent.Article.Id,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);

            // Expand parent and refresh
            parent.IsExpanded = true;
            await LoadChildrenForNode(parent);
            // Remove TreeState.SelectArticle(created) - wrong type

            Snackbar.Add("Child article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create child article: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadChildrenForNode(ArticleTreeNode node)
    {
        try
        {
            var children = await ArticleApi.GetChildrenAsync(node.Article.Id);
            node.Children = children.Select(c => new ArticleTreeNode(c)).ToList();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load children: {ex.Message}", Severity.Warning);
        }
    }

    private async Task DeleteArticle(ArticleTreeNode node)
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>(
            "confirm",
            $"Are you sure you want to delete '{node.Title}'? This action cannot be undone."
        );

        if (!confirmed) return;

        try
        {
            await ArticleApi.DeleteArticleAsync(node.Article.Id);
            await LoadRootArticles();
            Snackbar.Add("Article deleted", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    public void Dispose()
    {
        TreeState.OnRefreshRequested -= OnRefreshRequested;
    }

    // Helper class for tree nodes
    private class ArticleTreeNode
    {
        public ArticleDto Article { get; set; }
        public string Title => Article.Title ?? "New Article";
        public string? IconEmoji => Article.IconEmoji;
        public bool HasChildren { get; set; }
        public bool IsExpanded { get; set; }
        public bool IsHovered { get; set; }
        public List<ArticleTreeNode>? Children { get; set; }

        // Constructor for ArticleDto (from GetRootArticlesAsync)
        public ArticleTreeNode(ArticleDto article)
        {
            Article = article;
            HasChildren = article.ChildCount > 0;
        }

        // Constructor for ArticleTreeDto (from GetChildrenAsync)
        public ArticleTreeNode(ArticleTreeDto treeDto)
        {
            // Convert ArticleTreeDto to ArticleDto
            Article = new ArticleDto
            {
                Id = treeDto.Id,
                Title = treeDto.Title,
                ParentId = treeDto.ParentId,
                HasChildren = treeDto.HasChildren,
                ChildCount = treeDto.ChildCount,
                CreatedDate = treeDto.CreatedDate,
                EffectiveDate = treeDto.EffectiveDate,
                IconEmoji = treeDto.IconEmoji,
                Body = string.Empty  // TreeDto doesn't have body
            };
            HasChildren = treeDto.ChildCount > 0;
        }
    }
}
