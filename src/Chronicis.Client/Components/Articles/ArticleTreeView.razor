@inject ITreeStateService TreeState
@inject IArticleApiService ArticleApi
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@implements IDisposable

<div class="chronicis-nav-menu @(_isDragging ? "chronicis-nav-menu--dragging" : "")">
    @* Drop to Root Zone - shown when dragging *@
    @if (_isDragging)
    {
        <div class="chronicis-drop-to-root @(_isOverDropToRoot ? "drop-target-active" : "")"
             @ondragover="OnDragOverRoot"
             @ondragover:preventDefault="true"
             @ondragleave="OnDragLeaveRoot"
             @ondrop="OnDropToRoot"
             @ondrop:preventDefault="true">
            <MudIcon Icon="@Icons.Material.Filled.Home" Size="Size.Small" Class="mr-2" />
            <span>Drop here to make root article</span>
        </div>
    }

    @if (_isLoading)
    {
        <div class="pa-4">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
            <MudText Typo="Typo.body2" Class="ml-2" Style="display: inline;">
                Loading articles...
            </MudText>
        </div>
    }
    else if (TreeState.IsSearchActive && !HasVisibleArticles())
    {
        <div class="pa-4 text-center">
            <div style="opacity: 0.5; font-size: 2rem;">üîç</div>
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mt-2">
                No articles match "@TreeState.SearchQuery"
            </MudText>
        </div>
    }
    else if (_rootArticles == null || !_rootArticles.Any())
    {
        <div class="pa-4 text-center">
            <div style="opacity: 0.5; font-size: 3rem;">üìö</div>
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mt-2 mb-3">
                No articles yet
            </MudText>
            <MudButton 
                Variant="Variant.Text" 
                Color="Color.Primary"
                Size="Size.Small"
                StartIcon="@Icons.Material.Filled.Add"
                OnClick="CreateRootArticle">
                Create First Article
            </MudButton>
        </div>
    }
    else
    {
        <MudNavMenu Class="chronicis-nav-menu-items">
            @* Desktop link to dashboard *@
            <MudNavLink Href="/dashboard" 
                        Match="NavLinkMatch.All"
                        Class="chronicis-nav-item chronicis-desktop-link">
                <div class="d-flex align-center">
                    <div style="width: 30px;"></div>
                    <MudIcon Icon="@Icons.Material.Filled.Home" 
                             Color="Color.Primary" 
                             Size="Size.Small" 
                             Style="margin-right: 8px;" />
                    <span>Desktop</span>
                </div>
            </MudNavLink>
            
            <MudDivider Class="my-2" Style="opacity: 0.3;" />
            
            @foreach (var article in _rootArticles)
            {
                @RenderArticleNavItem(article)
            }
        </MudNavMenu>
    }
</div>

@code {
    private RenderFragment RenderArticleNavItem(ArticleTreeNode node) => __builder =>
    {
        // Hide nodes that don't match search filter
        if (TreeState.IsSearchActive && !TreeState.IsNodeVisible(node.Article.Id))
        {
            return;
        }

        var isDragSource = _draggedNode?.Article.Id == node.Article.Id;
        var isValidDropTarget = _isDragging && !isDragSource && !IsDescendantOfDraggedNode(node);
        var isDropTargetActive = _dropTargetNodeId == node.Article.Id;

        <div class="chronicis-nav-item-container @(isDragSource ? "dragging" : "") @(isDropTargetActive ? "drop-target-active" : "")" 
             draggable="true"
             @ondragstart="@((e) => OnDragStart(e, node))"
             @ondragstart:stopPropagation="true"
             @ondragend="OnDragEnd"
             @ondragend:stopPropagation="true"
             @ondragover="@((e) => OnDragOver(e, node))"
             @ondragover:preventDefault="@isValidDropTarget"
             @ondragover:stopPropagation="true"
             @ondragleave="@(() => OnDragLeave(node))"
             @ondragleave:stopPropagation="true"
             @ondrop="@((e) => OnDrop(e, node))"
             @ondrop:preventDefault="true"
             @ondrop:stopPropagation="true"
             @onmouseenter="@(() => node.IsHovered = true)"
             @onmouseleave="@(() => node.IsHovered = false)">
            
            <MudNavLink 
                OnClick="@(() => SelectArticle(node))"
                Class="@GetNavItemClass(node)">
                
                <div class="d-flex align-center justify-space-between" style="width: 100%;">
                    <div class="d-flex align-center">
                        <!-- Custom expand arrow BEFORE everything -->
                        @if (node.HasChildren)
                        {
                            <MudIconButton 
                                Icon="@(node.IsExpanded ? Icons.Material.Filled.ExpandMore : Icons.Material.Filled.ChevronRight)"
                                Size="Size.Small"
                                OnClick="@(async (e) => await ToggleExpand(node))"
                                Style="margin-right: 4px;" />
                        }
                        else
                        {
                            <!-- Spacer for alignment when no arrow -->
                            <div style="width: 30px;"></div>
                        }
                        
                        <!-- Drag handle icon (visible on hover or when dragging) -->
                        <MudIcon 
                            Icon="@Icons.Material.Filled.DragIndicator" 
                            Size="Size.Small" 
                            Class="drag-handle"
                            Style="@(node.IsHovered || _isDragging ? "opacity: 0.6;" : "opacity: 0;")" />
                        
                        <!-- Article icon (emoji or Material icon fallback) -->
                        @if (!string.IsNullOrEmpty(node.IconEmoji))
                        {
                            <span class="chronicis-tree-emoji" style="margin-right: 8px; font-size: 1.1rem;">@node.IconEmoji</span>
                        }
                        else
                        {
                            <MudIcon 
                                Icon="@(node.HasChildren ? Icons.Material.Filled.Folder : Icons.Material.Filled.Description)" 
                                Color="Color.Primary" 
                                Size="Size.Small" 
                                Style="margin-right: 8px;" />
                        }
                        
                        <span>@node.Title</span>
                    </div>
                    
                    <!-- Context menu (three dots) - always show, style with opacity -->
                    <MudMenu 
                        AnchorOrigin="Origin.BottomRight"
                        TransformOrigin="Origin.TopRight"
                        Dense="true"
                        Style="@(node.IsHovered ? "opacity: 1;" : "opacity: 0.3;")">
                        <ActivatorContent>
                            <MudIconButton 
                                Icon="@Icons.Material.Filled.MoreVert" 
                                Size="Size.Small"
                                Class="chronicis-nav-item-menu"
                                @onclick:stopPropagation="true" />
                        </ActivatorContent>
                        <ChildContent>
                            <MudMenuItem 
                                Icon="@Icons.Material.Filled.Add"
                                OnClick="@(() => CreateChildArticle(node))">
                                Add Child
                            </MudMenuItem>
                            <MudMenuItem 
                                Icon="@Icons.Material.Filled.Delete"
                                OnClick="@(() => DeleteArticle(node))">
                                Delete
                            </MudMenuItem>
                        </ChildContent>
                    </MudMenu>
                </div>
            </MudNavLink>
            
            <!-- Render children if expanded -->
            @if (node.HasChildren && node.IsExpanded && node.Children != null)
            {
                <div class="chronicis-nav-children">
                    @foreach (var child in node.Children)
                    {
                        @RenderArticleNavItem(child)
                    }
                </div>
            }
        </div>
    };

    private List<ArticleTreeNode>? _rootArticles;
    private ArticleTreeNode? _selectedNode;
    private bool _isLoading = true;

    // Drag-and-drop state
    private bool _isDragging = false;
    private ArticleTreeNode? _draggedNode = null;
    private Guid? _dropTargetNodeId = null;
    private bool _isOverDropToRoot = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadRootArticles();
        TreeState.OnRefreshRequested += OnRefreshRequested;
        TreeState.OnStateChanged += OnTreeStateChanged;
        TreeState.OnExpandAndSelect += OnExpandAndSelectRequested;
    }

    #region Drag-and-Drop Handlers

    private void OnDragStart(DragEventArgs e, ArticleTreeNode node)
    {
        _isDragging = true;
        _draggedNode = node;
        _dropTargetNodeId = null;
        StateHasChanged();
    }

    private void OnDragEnd()
    {
        _isDragging = false;
        _draggedNode = null;
        _dropTargetNodeId = null;
        _isOverDropToRoot = false;
        StateHasChanged();
    }

    private void OnDragOver(DragEventArgs e, ArticleTreeNode node)
    {
        if (_draggedNode == null) return;
        
        // Can't drop on self
        if (_draggedNode.Article.Id == node.Article.Id) return;
        
        // Can't drop on a descendant
        if (IsDescendantOfDraggedNode(node)) return;
        
        _dropTargetNodeId = node.Article.Id;
        StateHasChanged();
    }

    private void OnDragLeave(ArticleTreeNode node)
    {
        if (_dropTargetNodeId == node.Article.Id)
        {
            _dropTargetNodeId = null;
            StateHasChanged();
        }
    }

    private async Task OnDrop(DragEventArgs e, ArticleTreeNode targetNode)
    {
        if (_draggedNode == null) return;
        
        var draggedId = _draggedNode.Article.Id;
        var targetId = targetNode.Article.Id;
        
        // Validate drop target
        if (draggedId == targetId || IsDescendantOfDraggedNode(targetNode))
        {
            Snackbar.Add("Cannot move an article into itself or its children", Severity.Warning);
            OnDragEnd();
            return;
        }
        
        // Perform the move via API
        await MoveArticleToParent(draggedId, targetId);
        OnDragEnd();
    }

    private void OnDragOverRoot(DragEventArgs e)
    {
        if (_draggedNode == null) return;
        
        // Only valid if article is not already a root
        if (_draggedNode.Article.ParentId != null)
        {
            _isOverDropToRoot = true;
            StateHasChanged();
        }
    }

    private void OnDragLeaveRoot()
    {
        _isOverDropToRoot = false;
        StateHasChanged();
    }

    private async Task OnDropToRoot(DragEventArgs e)
    {
        if (_draggedNode == null) return;
        
        var draggedId = _draggedNode.Article.Id;
        
        // Already a root article - no action needed
        if (_draggedNode.Article.ParentId == null)
        {
            OnDragEnd();
            return;
        }
        
        // Perform the move via API (null = root level)
        await MoveArticleToParent(draggedId, null);
        OnDragEnd();
    }

    private bool IsDescendantOfDraggedNode(ArticleTreeNode node)
    {
        if (_draggedNode == null) return false;
        
        // Check if node is a descendant of the dragged node
        return IsInSubtree(_draggedNode, node.Article.Id);
    }

    private bool IsInSubtree(ArticleTreeNode root, Guid targetId)
    {
        if (root.Article.Id == targetId) return true;
        
        if (root.Children != null)
        {
            foreach (var child in root.Children)
            {
                if (IsInSubtree(child, targetId)) return true;
            }
        }
        
        return false;
    }

    private async Task MoveArticleToParent(Guid articleId, Guid? newParentId)
    {
        try
        {
            var success = await ArticleApi.MoveArticleAsync(articleId, newParentId);
            
            if (success)
            {
                Snackbar.Add("Article moved successfully", Severity.Success);
                
                // Refresh the tree
                await LoadRootArticles();
                
                // Expand path to and select the moved article
                await ExpandAndSelectNode(articleId);
            }
            else
            {
                Snackbar.Add("Failed to move article", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error moving article: {ex.Message}", Severity.Error);
        }
    }

    #endregion

    private async void OnExpandAndSelectRequested(Guid articleId)
    {
        await InvokeAsync(async () =>
        {
            await ExpandAndSelectNode(articleId);
        });
    }

    private async Task LoadRootArticles()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            var articles = await ArticleApi.GetRootArticlesAsync();
            _rootArticles = articles.Select(a => new ArticleTreeNode(a)).ToList();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load articles: {ex.Message}", Severity.Error);
            _rootArticles = new List<ArticleTreeNode>();
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async void OnRefreshRequested()
    {
        await InvokeAsync(async () =>
        {
            await LoadRootArticles();
            StateHasChanged();
        });
    }

    private async void OnTreeStateChanged()
    {
        await InvokeAsync(() =>
        {
            // When search state changes, auto-expand matching ancestors
            if (TreeState.IsSearchActive)
            {
                ExpandSearchMatches();
            }
            StateHasChanged();
        });
    }

    private void ExpandSearchMatches()
    {
        if (_rootArticles == null) return;

        // Expand all nodes that are visible in the search
        ExpandVisibleNodes(_rootArticles);
    }

    private void ExpandVisibleNodes(List<ArticleTreeNode> nodes)
    {
        foreach (var node in nodes)
        {
            if (TreeState.IsNodeVisible(node.Article.Id))
            {
                // If this node is visible and has children, expand it
                if (node.HasChildren)
                {
                    node.IsExpanded = true;
                    
                    // Load children if not already loaded
                    if (node.Children == null || !node.Children.Any())
                    {
                        _ = LoadChildrenForNode(node);
                    }
                    else if (node.Children != null)
                    {
                        ExpandVisibleNodes(node.Children);
                    }
                }
            }
        }
    }

    private bool HasVisibleArticles()
    {
        if (_rootArticles == null) return false;
        return HasVisibleArticlesRecursive(_rootArticles);
    }

    private bool HasVisibleArticlesRecursive(List<ArticleTreeNode> nodes)
    {
        foreach (var node in nodes)
        {
            if (TreeState.IsNodeVisible(node.Article.Id))
                return true;
            
            if (node.Children != null && HasVisibleArticlesRecursive(node.Children))
                return true;
        }
        return false;
    }

    private async Task SelectArticle(ArticleTreeNode node)
    {
        _selectedNode = node;

        TreeState.NotifySelectionChanged(node.Article.Id);

        // Get full article details to build hierarchical path
        var article = await ArticleApi.GetArticleDetailAsync(node.Article.Id);
        if (article != null && article.Breadcrumbs.Any())
        {
            var path = string.Join("/", article.Breadcrumbs.Select(b => b.Slug));
            Navigation.NavigateTo($"/article/{path}");
        }

        // Auto-expand if has children
        if (node.HasChildren && !node.IsExpanded)
        {
            node.IsExpanded = true;

            if (node.Children == null || !node.Children.Any())
            {
                _ = LoadChildrenForNode(node);
            }
        }

        StateHasChanged();
    }

    private string GetNavItemClass(ArticleTreeNode node)
    {
        return _selectedNode?.Article.Id == node.Article.Id 
            ? "chronicis-nav-item-selected" 
            : "chronicis-nav-item";
    }

    private async Task ToggleExpand(ArticleTreeNode node)
    {
        node.IsExpanded = !node.IsExpanded;
        
        if (node.IsExpanded && (node.Children == null || !node.Children.Any()))
        {
            await LoadChildrenForNode(node);
        }
        
        StateHasChanged();
    }

    private async Task CreateRootArticle()
    {
        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = string.Empty,
                Body = string.Empty,
                ParentId = null,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            await LoadRootArticles();
            
            // Select the new article
            var newNode = _rootArticles?.FirstOrDefault(a => a.Article.Id == created.Id);
            if (newNode != null)
            {
                await SelectArticle(newNode);
            }
            
            Snackbar.Add("Article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateChildArticle(ArticleTreeNode parent)
    {
        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = string.Empty,
                Body = string.Empty,
                ParentId = parent.Article.Id,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);

            // Reload children to get updated list
            await LoadChildrenForNode(parent);
            
            // Update parent's HasChildren flag
            parent.HasChildren = parent.Children?.Any() ?? false;
            parent.Article.ChildCount = parent.Children?.Count ?? 0;
            
            // Expand parent to show new child
            parent.IsExpanded = true;
            
            // Find and select the newly created child
            var newChild = parent.Children?.FirstOrDefault(c => c.Article.Id == created.Id);
            if (newChild != null)
            {
                await SelectArticle(newChild);
            }

            Snackbar.Add("Child article created", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create child article: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadChildrenForNode(ArticleTreeNode node)
    {
        try
        {
            var children = await ArticleApi.GetChildrenAsync(node.Article.Id);
            node.Children = children.Select(c => new ArticleTreeNode(c)).ToList();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load children: {ex.Message}", Severity.Warning);
        }
    }

    private async Task DeleteArticle(ArticleTreeNode node)
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>(
            "confirm",
            $"Are you sure you want to delete '{node.Title}'? This action cannot be undone."
        );

        if (!confirmed) return;

        try
        {
            var parentId = node.Article.ParentId;
            
            await ArticleApi.DeleteArticleAsync(node.Article.Id);
            await LoadRootArticles();
            
            // If there was a parent, select it and expand the path to it
            if (parentId.HasValue)
            {
                await ExpandAndSelectNode(parentId.Value);
            }
            else
            {
                _selectedNode = null;
            }
            
            Snackbar.Add("Article deleted", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    private async Task ExpandAndSelectNode(Guid targetId)
    {
        // Get the full article to get its breadcrumbs
        var article = await ArticleApi.GetArticleAsync(targetId);
        if (article == null)
        {
            return;
        }
        
        // Expand each ancestor in the breadcrumb path
        List<ArticleTreeNode>? currentLevel = _rootArticles;
        ArticleTreeNode? targetNode = null;
        
        // Go through each breadcrumb (these are the ancestors)
        foreach (var breadcrumb in article.Breadcrumbs)
        {
            var node = FindNodeById(currentLevel, breadcrumb.Id);
            
            if (node == null)
            {
                return;
            }
            
            node.IsExpanded = true;
            
            // Load children if needed
            if (node.HasChildren && (node.Children == null || !node.Children.Any()))
            {
                await LoadChildrenForNode(node);
            }
            
            // If this breadcrumb IS the target, we're done
            if (breadcrumb.Id == targetId)
            {
                targetNode = node;
                break;
            }
            
            // Move down to children for next iteration
            currentLevel = node.Children;
        }
        
        // Select the target node
        if (targetNode != null)
        {
            _selectedNode = targetNode;
            TreeState.NotifySelectionChanged(targetId);
            StateHasChanged();
        }
    }

    private ArticleTreeNode? FindNodeById(List<ArticleTreeNode>? nodes, Guid id)
    {
        if (nodes == null) return null;
        
        foreach (var node in nodes)
        {
            if (node.Article.Id == id)
                return node;
            
            var found = FindNodeById(node.Children, id);
            if (found != null)
                return found;
        }
        
        return null;
    }

    public void Dispose()
    {
        TreeState.OnRefreshRequested -= OnRefreshRequested;
        TreeState.OnStateChanged -= OnTreeStateChanged;
        TreeState.OnExpandAndSelect -= OnExpandAndSelectRequested;
    }

    // Helper class for tree nodes
    private class ArticleTreeNode
    {
        public ArticleDto Article { get; set; }
        public string Title => string.IsNullOrEmpty(Article.Title) ? "(Untitled)" : Article.Title;
        public string? IconEmoji => Article.IconEmoji;
        public bool HasChildren { get; set; }
        public bool IsExpanded { get; set; }
        public bool IsHovered { get; set; }
        public List<ArticleTreeNode>? Children { get; set; }

        // Constructor for ArticleDto (from GetRootArticlesAsync)
        public ArticleTreeNode(ArticleDto article)
        {
            Article = article;
            HasChildren = article.ChildCount > 0;
        }

        // Constructor for ArticleTreeDto (from GetChildrenAsync)
        public ArticleTreeNode(ArticleTreeDto treeDto)
        {
            // Convert ArticleTreeDto to ArticleDto
            Article = new ArticleDto
            {
                Id = treeDto.Id,
                Title = treeDto.Title,
                ParentId = treeDto.ParentId,
                HasChildren = treeDto.HasChildren,
                ChildCount = treeDto.ChildCount,
                CreatedAt = treeDto.CreatedAt,
                EffectiveDate = treeDto.EffectiveDate,
                IconEmoji = treeDto.IconEmoji,
                Body = string.Empty
            };
            HasChildren = treeDto.ChildCount > 0;
        }
    }
}
