<style>
    .article-tree {
        width: 100%;
    }

    .tree-item {
        width: 100%;
    }

    .tree-item-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        padding: 4px 8px;
        border-radius: 4px;
        transition: background-color 0.2s ease;
        font-size: 1.5rem;
    }

        .tree-item-content:hover {
            background-color: rgba(196, 175, 142, 0.1); /* Beige-gold with opacity */
        }

        .tree-item-content .selected-item {
            font-weight: 600;
            color: #C4AF8E; /* Beige-gold */
            background-color: rgba(196, 175, 142, 0.2);
        }

    .tree-item-menu {
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .tree-item:hover .tree-item-menu,
    .tree-item-content:hover .tree-item-menu {
        opacity: 1;
    }

    /* Ensure menu button is small and unobtrusive */
    .tree-item-menu button {
        padding: 4px;
        min-width: unset;
    }

    /* Add subtle hover glow effect */
    .tree-item-content:hover {
        box-shadow: 0 0 8px rgba(196, 175, 142, 0.3);
    }

    /* PHASE 3: Empty state styling */
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 48px 24px;
        text-align: center;
        color: var(--mud-palette-text-secondary);
    }

    .empty-state .mud-icon-root {
        margin-bottom: 16px;
        opacity: 0.5;
    }

    .empty-state .mud-typography-h6 {
        margin-bottom: 8px;
    }
</style>
@using Chronicis.Shared.Models
@using Chronicis.Client.ViewModels
@inject IJSRuntime JSRuntime
@inject ArticleApiService ArticleApiService
@inject TreeStateService TreeStateService
@inject IDialogService DialogService
@inject ISnackbar Snackbar
@implements IDisposable

@* PHASE 3: Show empty state if search returns no results *@
@if (TreeStateService.IsSearchActive && !GetFilteredTreeItems().Any())
{
    <div class="empty-state">
        <MudIcon Icon="@Icons.Material.Filled.SearchOff" Size="Size.Large" />
        <MudText Typo="Typo.h6">No results found</MudText>
        <MudText Typo="Typo.body2">Try a different search term</MudText>
    </div>
}
else
{
    <MudTreeView T="ArticleTreeItemViewModel" 
                 Items="@GetTreeItemData()"
                 Hover="true"
                 Dense="false"
                 Class="article-tree">
        <ItemTemplate>
            <MudTreeViewItem @bind-Expanded="@context.Expanded"
                             Value="@context.Value"
                             Items="@context.Children"
                             Selected="@(context.Value?.IsSelected == true)"
                             Class="article-tree-view-item"
            >
                <Content>
                    <div class="tree-item-content" @onclick ="@(() => OnArticleSelectedInternal(context.Value))">
                        <span>
                            <MudMenu Icon="@GetTreeViewIcon(context.Expanded)"
                                     Color="Color.Primary" />
                            @context.Value?.Title
                        </span>
                        @* PHASE 3: Hide context menu during search for cleaner UI *@
                        @if (!TreeStateService.IsSearchActive)
                        {
                            <MudMenu Icon="@Icons.Material.Filled.MoreVert"
                                     Color=Color.Primary
                                     Size="Size.Small"
                                     Class="tree-item-menu"
                                     AnchorOrigin="Origin.BottomRight"
                                     TransformOrigin="Origin.TopRight"
                                     @onclick:stopPropagation="true">
                                <MudMenuItem OnClick="@(() => OnAddChild(context.Value))">
                                    <MudIcon Icon="@Icons.Material.Filled.Add" Size="Size.Small" Class="mr-2" />
                                    Add Child
                                </MudMenuItem>
                                <MudDivider />
                                <MudMenuItem OnClick="@(() => OnDelete(context.Value))">
                                    <MudIcon Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="Color.Error" Class="mr-2" />
                                    <span style="color: var(--mud-palette-error);">Delete</span>
                                </MudMenuItem>
                            </MudMenu>
                        }
                    </div>
                </Content>
            </MudTreeViewItem>
        </ItemTemplate>
    </MudTreeView>
}

@code {
    [Parameter]
    public List<ArticleTreeItemViewModel> TreeItems { get; set; } = new();

    [Parameter]
    public EventCallback<ArticleTreeItemViewModel> OnArticleSelected { get; set; }

    protected override void OnInitialized()
    {
        // Register keyboard shortcuts
        JSRuntime.InvokeVoidAsync("registerKeyboardShortcuts");
        TreeStateService.OnStateChanged += StateHasChanged;
    }

    public void Dispose()
    {
        TreeStateService.OnStateChanged -= StateHasChanged;
    }

    private string GetTreeViewIcon(bool expanded)
    {
        if (expanded)
        {
            return Icons.Material.Filled.ArrowDropDown;
        }
        else
        {
            return Icons.Material.Filled.ArrowRight;
        }
    }

    // PHASE 3: Filter tree items based on search visibility
    private List<ArticleTreeItemViewModel> GetFilteredTreeItems()
    {
        if (!TreeStateService.IsSearchActive)
        {
            return TreeItems;
        }

        return TreeItems.Where(item => TreeStateService.IsNodeVisible(item.Id)).ToList();
    }

    private List<TreeItemData<ArticleTreeItemViewModel>> GetTreeItemData()
    {
        var treeItemData = new List<TreeItemData<ArticleTreeItemViewModel>>();

        // PHASE 3: Use filtered items instead of all items
        foreach (var item in GetFilteredTreeItems())
        {
            treeItemData.Add(ConvertToTreeItemData(item));
        }

        return treeItemData;
    }

    private TreeItemData<ArticleTreeItemViewModel> ConvertToTreeItemData(ArticleTreeItemViewModel viewModel)
    {
        var children = new List<TreeItemData<ArticleTreeItemViewModel>>();

        // Recursively convert all children that are already loaded
        if (viewModel.Children?.Any() == true)
        {
            foreach (var child in viewModel.Children)
            {
                // ALWAYS show children when search is not active
                // Only filter when search IS active
                if (!TreeStateService.IsSearchActive || TreeStateService.IsNodeVisible(child.Id))
                {
                    children.Add(ConvertToTreeItemData(child));
                }
            }
        }

        var treeItem = new TreeItemData<ArticleTreeItemViewModel>
        {
            Value = viewModel,
            // Don't override expansion during normal use - only during search
            Expanded = TreeStateService.IsSearchActive
                ? (viewModel.IsExpanded || children.Any())
                : viewModel.IsSelected,  // <-- CHANGED: Use IsSelected like your original
            Expandable = viewModel.HasChildren || viewModel.Children.Any(),
            Children = children
        };

        return treeItem;
    }

    private async Task OnArticleSelectedInternal(ArticleTreeItemViewModel? item)
    {
        if (item != null)
        {
            await OnArticleSelected.InvokeAsync(item);
        }
    }

    private async Task OnAddChild(ArticleTreeItemViewModel? parent)
    {
        if (parent == null) return;

        try
        {
            // Create blank article immediately
            var created = await ArticleApiService.CreateArticleAsync(new ArticleCreateDto
            {
                Title = "Untitled",
                ParentId = parent.Id,
                Body = string.Empty
            });

            // Add to tree
            await TreeStateService.AddArticleAsync(created);

            // The article is now selected and ArticleDetail will show it for editing
            Snackbar.Add("New article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private async Task OnDelete(ArticleTreeItemViewModel? item)
    {
        if (item == null) return;

        string message;
        if (item.Children?.Any() == true)
        {
            message = $"'{item.Title}' has {item.Children.Count} child article(s). Deleting it will also delete all children. This action cannot be undone. Are you sure?";
        }
        else
        {
            message = $"Are you sure you want to delete '{item.Title}'? This action cannot be undone.";
        }

        var result = await DialogService.ShowMessageBox(
            "Delete Article",
            message,
            yesText: "Delete",
            cancelText: "Cancel");

        if (result == true)
        {
            try
            {
                await ArticleApiService.DeleteArticleAsync(item.Id);
                await TreeStateService.RemoveArticleAsync(item.Id);
                Snackbar.Add("Article deleted successfully!", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to delete article: {ex.Message}", Severity.Error);
            }
        }
    }
}
