@inject ITreeStateService TreeState
@inject IArticleApiService ArticleApi
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@implements IDisposable

<div class="chronicis-nav-menu">
    @if (_isLoading)
    {
        <div class="pa-4">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
            <MudText Typo="Typo.body2" Class="ml-2" Style="display: inline;">
                Loading articles...
            </MudText>
        </div>
    }
    else if (TreeState.IsSearchActive && !HasVisibleArticles())
    {
        <div class="pa-4 text-center">
            <div style="opacity: 0.5; font-size: 2rem;">üîç</div>
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mt-2">
                No articles match "@TreeState.SearchQuery"
            </MudText>
        </div>
    }
    else if (_rootArticles == null || !_rootArticles.Any())
    {
        <div class="pa-4 text-center">
            <div style="opacity: 0.5; font-size: 3rem;">üìö</div>
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mt-2 mb-3">
                No articles yet
            </MudText>
            <MudButton 
                Variant="Variant.Text" 
                Color="Color.Primary"
                Size="Size.Small"
                StartIcon="@Icons.Material.Filled.Add"
                OnClick="CreateRootArticle">
                Create First Article
            </MudButton>
        </div>
    }
    else
    {
        <MudNavMenu Class="chronicis-nav-menu-items">
            @foreach (var article in _rootArticles)
            {
                @RenderArticleNavItem(article)
            }
        </MudNavMenu>
    }
</div>

@code {
    private RenderFragment RenderArticleNavItem(ArticleTreeNode node) => __builder =>
    {
        // Hide nodes that don't match search filter
        if (TreeState.IsSearchActive && !TreeState.IsNodeVisible(node.Article.Id))
        {
            return;
        }

        <div class="chronicis-nav-item-container" 
             @onmouseenter="@(() => node.IsHovered = true)"
             @onmouseleave="@(() => node.IsHovered = false)">
            
            <MudNavLink 
                OnClick="@(() => SelectArticle(node))"
                Class="@GetNavItemClass(node)">
                
                <div class="d-flex align-center justify-space-between" style="width: 100%;">
                    <div class="d-flex align-center">
                        <!-- Custom expand arrow BEFORE everything -->
                        @if (node.HasChildren)
                        {
                            <MudIconButton 
                                Icon="@(node.IsExpanded ? Icons.Material.Filled.ExpandMore : Icons.Material.Filled.ChevronRight)"
                                Size="Size.Small"
                                OnClick="@(async (e) => await ToggleExpand(node))"
                                Style="margin-right: 4px;" />
                        }
                        else
                        {
                            <!-- Spacer for alignment when no arrow -->
                            <div style="width: 30px;"></div>
                        }
                        
                        <!-- Article icon -->
                        <MudIcon 
                            Icon="@GetNodeIcon(node)" 
                            Color="Color.Primary" 
                            Size="Size.Small" 
                            Style="margin-right: 8px;" />
                        
                        <span>@node.Title</span>
                    </div>
                    
                    <!-- Context menu (three dots) - always show, style with opacity -->
                    <MudMenu 
                        AnchorOrigin="Origin.BottomRight"
                        TransformOrigin="Origin.TopRight"
                        Dense="true"
                        Style="@(node.IsHovered ? "opacity: 1;" : "opacity: 0.3;")">
                        <ActivatorContent>
                            <MudIconButton 
                                Icon="@Icons.Material.Filled.MoreVert" 
                                Size="Size.Small"
                                Class="chronicis-nav-item-menu"
                                @onclick:stopPropagation="true" />
                        </ActivatorContent>
                        <ChildContent>
                            <MudMenuItem 
                                Icon="@Icons.Material.Filled.Add"
                                OnClick="@(() => CreateChildArticle(node))">
                                Add Child
                            </MudMenuItem>
                            <MudMenuItem 
                                Icon="@Icons.Material.Filled.Delete"
                                OnClick="@(() => DeleteArticle(node))">
                                Delete
                            </MudMenuItem>
                        </ChildContent>
                    </MudMenu>
                </div>
            </MudNavLink>
            
            <!-- Render children if expanded -->
            @if (node.HasChildren && node.IsExpanded && node.Children != null)
            {
                <div class="chronicis-nav-children">
                    @foreach (var child in node.Children)
                    {
                        @RenderArticleNavItem(child)
                    }
                </div>
            }
        </div>
    };

    private List<ArticleTreeNode>? _rootArticles;
    private ArticleTreeNode? _selectedNode;
    private bool _isLoading = true;

    protected override async Task OnInitializedAsync()
    {
        await LoadRootArticles();
        TreeState.OnRefreshRequested += OnRefreshRequested;
        TreeState.OnStateChanged += OnTreeStateChanged;
        TreeState.OnExpandAndSelect += OnExpandAndSelectRequested;
    }

    private async void OnExpandAndSelectRequested(int articleId)
    {

        await InvokeAsync(async () =>
        {
            await ExpandAndSelectNode(articleId);
        });
    }

    private async Task LoadRootArticles()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            var articles = await ArticleApi.GetRootArticlesAsync();
            _rootArticles = articles.Select(a => new ArticleTreeNode(a)).ToList();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load articles: {ex.Message}", Severity.Error);
            _rootArticles = new List<ArticleTreeNode>();
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async void OnRefreshRequested()
    {
        await InvokeAsync(async () =>
        {
            await LoadRootArticles();
            StateHasChanged();
        });
    }

    private async void OnTreeStateChanged()
    {
        await InvokeAsync(() =>
        {
            // When search state changes, auto-expand matching ancestors
            if (TreeState.IsSearchActive)
            {
                ExpandSearchMatches();
            }
            StateHasChanged();
        });
    }

    private void ExpandSearchMatches()
    {
        if (_rootArticles == null) return;

        // Expand all nodes that are visible in the search
        ExpandVisibleNodes(_rootArticles);
    }

    private void ExpandVisibleNodes(List<ArticleTreeNode> nodes)
    {
        foreach (var node in nodes)
        {
            if (TreeState.IsNodeVisible(node.Article.Id))
            {
                // If this node is visible and has children, expand it
                if (node.HasChildren)
                {
                    node.IsExpanded = true;
                    
                    // Load children if not already loaded
                    if (node.Children == null || !node.Children.Any())
                    {
                        _ = LoadChildrenForNode(node);
                    }
                    else if (node.Children != null)
                    {
                        ExpandVisibleNodes(node.Children);
                    }
                }
            }
        }
    }

    private bool HasVisibleArticles()
    {
        if (_rootArticles == null) return false;
        return HasVisibleArticlesRecursive(_rootArticles);
    }

    private bool HasVisibleArticlesRecursive(List<ArticleTreeNode> nodes)
    {
        foreach (var node in nodes)
        {
            if (TreeState.IsNodeVisible(node.Article.Id))
                return true;
            
            if (node.Children != null && HasVisibleArticlesRecursive(node.Children))
                return true;
        }
        return false;
    }

    private void SelectArticle(ArticleTreeNode node)
    {
        _selectedNode = node;

        TreeState.NotifySelectionChanged(node.Article.Id);


        // Navigate to article URL using slug for deep linking
        var slug = CreateSlug(node.Title);
        Navigation.NavigateTo($"/article/{slug}");

        // Auto-expand if has children
        if (node.HasChildren && !node.IsExpanded)
        {
            node.IsExpanded = true;

            if (node.Children == null || !node.Children.Any())
            {
                _ = LoadChildrenForNode(node);
            }
        }

        StateHasChanged();
    }

    private static string CreateSlug(string title)
    {
        if (string.IsNullOrEmpty(title) || title == "(Untitled)")
            return "untitled";
        
        // Convert to lowercase
        var slug = title.ToLowerInvariant();
        
        // Replace spaces with hyphens
        slug = slug.Replace(" ", "-");
        
        // Remove invalid characters (keep only letters, numbers, hyphens)
        slug = new string(slug.Where(c => char.IsLetterOrDigit(c) || c == '-').ToArray());
        
        // Replace multiple consecutive hyphens with single hyphen
        while (slug.Contains("--"))
        {
            slug = slug.Replace("--", "-");
        }
        
        // Trim hyphens from start and end
        slug = slug.Trim('-');
        
        return string.IsNullOrEmpty(slug) ? "untitled" : slug;
    }

    private string GetNavItemClass(ArticleTreeNode node)
    {
        return _selectedNode?.Article.Id == node.Article.Id 
            ? "chronicis-nav-item-selected" 
            : "chronicis-nav-item";
    }

    private string GetNodeIcon(ArticleTreeNode node)
    {
        if (!string.IsNullOrEmpty(node.IconEmoji))
        {
            return node.IconEmoji;
        }
        
        return node.HasChildren 
            ? Icons.Material.Filled.Folder 
            : Icons.Material.Filled.Description;
    }

    private async Task ToggleExpand(ArticleTreeNode node)
    {
        node.IsExpanded = !node.IsExpanded;
        
        if (node.IsExpanded && (node.Children == null || !node.Children.Any()))
        {
            await LoadChildrenForNode(node);
        }
        
        StateHasChanged();
    }

    private async Task CreateRootArticle()
    {
        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = string.Empty,
                Body = string.Empty,
                ParentId = null,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            await LoadRootArticles();
            
            // Select the new article
            var newNode = _rootArticles?.FirstOrDefault(a => a.Article.Id == created.Id);
            if (newNode != null)
            {
                SelectArticle(newNode);
            }
            
            Snackbar.Add("Article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateChildArticle(ArticleTreeNode parent)
    {
        try
        {
            var createDto = new ArticleCreateDto
            {
                Title = string.Empty,
                Body = string.Empty,
                ParentId = parent.Article.Id,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);

            // Reload children to get updated list
            await LoadChildrenForNode(parent);
            
            // Update parent's HasChildren flag
            parent.HasChildren = parent.Children?.Any() ?? false;
            parent.Article.ChildCount = parent.Children?.Count ?? 0;
            
            // Expand parent to show new child
            parent.IsExpanded = true;
            
            // Find and select the newly created child
            var newChild = parent.Children?.FirstOrDefault(c => c.Article.Id == created.Id);
            if (newChild != null)
            {
                SelectArticle(newChild);
            }

            Snackbar.Add("Child article created", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create child article: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadChildrenForNode(ArticleTreeNode node)
    {
        try
        {
            var children = await ArticleApi.GetChildrenAsync(node.Article.Id);
            node.Children = children.Select(c => new ArticleTreeNode(c)).ToList();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load children: {ex.Message}", Severity.Warning);
        }
    }

    private async Task DeleteArticle(ArticleTreeNode node)
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>(
            "confirm",
            $"Are you sure you want to delete '{node.Title}'? This action cannot be undone."
        );

        if (!confirmed) return;

        try
        {
            var parentId = node.Article.ParentId;
            
            await ArticleApi.DeleteArticleAsync(node.Article.Id);
            await LoadRootArticles();
            
            // If there was a parent, select it and expand the path to it
            if (parentId.HasValue)
            {
                await ExpandAndSelectNode(parentId.Value);
            }
            else
            {
                _selectedNode = null;
            }
            
            Snackbar.Add("Article deleted", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    private async Task ExpandAndSelectNode(int targetId)
    {
        // Get the full article to get its breadcrumbs
        var article = await ArticleApi.GetArticleAsync(targetId);
        if (article == null)
        {
            return;
        }
        
        // Expand each ancestor in the breadcrumb path
        List<ArticleTreeNode>? currentLevel = _rootArticles;
        ArticleTreeNode? targetNode = null;
        
        // Go through each breadcrumb (these are the ancestors)
        foreach (var breadcrumb in article.Breadcrumbs)
        {
            var node = FindNodeById(currentLevel, breadcrumb.Id);
            
            if (node == null)
            {
                return;
            }
            
            node.IsExpanded = true;
            
            // Load children if needed
            if (node.HasChildren && (node.Children == null || !node.Children.Any()))
            {
                await LoadChildrenForNode(node);
            }
            
            // If this breadcrumb IS the target, we're done
            if (breadcrumb.Id == targetId)
            {
                targetNode = node;
                break;
            }
            
            // Move down to children for next iteration
            currentLevel = node.Children;
        }
        
        // Select the target node
        if (targetNode != null)
        {
            _selectedNode = targetNode;
            TreeState.NotifySelectionChanged(targetId);
            StateHasChanged();
        }
    }

    private ArticleTreeNode? FindNodeById(List<ArticleTreeNode>? nodes, int id)
    {
        if (nodes == null) return null;
        
        foreach (var node in nodes)
        {
            if (node.Article.Id == id)
                return node;
            
            var found = FindNodeById(node.Children, id);
            if (found != null)
                return found;
        }
        
        return null;
    }

    public void Dispose()
    {
        TreeState.OnRefreshRequested -= OnRefreshRequested;
        TreeState.OnStateChanged -= OnTreeStateChanged;
        TreeState.OnExpandAndSelect -= OnExpandAndSelectRequested;  // NEW
    }

    // Helper class for tree nodes
    private class ArticleTreeNode
    {
        public ArticleDto Article { get; set; }
        public string Title => string.IsNullOrEmpty(Article.Title) ? "(Untitled)" : Article.Title;
        public string? IconEmoji => Article.IconEmoji;
        public bool HasChildren { get; set; }
        public bool IsExpanded { get; set; }
        public bool IsHovered { get; set; }
        public List<ArticleTreeNode>? Children { get; set; }

        // Constructor for ArticleDto (from GetRootArticlesAsync)
        public ArticleTreeNode(ArticleDto article)
        {
            Article = article;
            HasChildren = article.ChildCount > 0;
        }

        // Constructor for ArticleTreeDto (from GetChildrenAsync)
        public ArticleTreeNode(ArticleTreeDto treeDto)
        {
            // Convert ArticleTreeDto to ArticleDto
            Article = new ArticleDto
            {
                Id = treeDto.Id,
                Title = treeDto.Title,
                ParentId = treeDto.ParentId,
                HasChildren = treeDto.HasChildren,
                ChildCount = treeDto.ChildCount,
                CreatedDate = treeDto.CreatedDate,
                EffectiveDate = treeDto.EffectiveDate,
                IconEmoji = treeDto.IconEmoji,
                Body = string.Empty
            };
            HasChildren = treeDto.ChildCount > 0;
        }
    }
}
