@using Chronicis.Client.Models
@using Chronicis.Client.Components.Dialogs
@using Chronicis.Shared.DTOs
@inject ITreeStateService TreeState
@inject ISnackbar Snackbar
@inject NavigationManager Navigation
@inject IArticleApiService ArticleApi
@inject IAppContextService AppContext
@inject IDialogService DialogService
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="article-tree @(_draggedNodeId.HasValue ? "article-tree--dragging" : "")">
    @if (TreeState.IsLoading)
    {
        <div class="article-tree__loading">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
            <MudText Typo="Typo.body2" Class="ml-2">Loading...</MudText>
        </div>
    }
    else if (!TreeState.RootNodes.Any())
    {
        <div class="article-tree__empty">
            <div class="article-tree__empty-icon">üåç</div>
            <MudText Typo="Typo.body2" Class="mt-2 mb-3">No worlds yet</MudText>
            <MudButton 
                Variant="Variant.Text" 
                Color="Color.Primary"
                Size="Size.Small"
                StartIcon="@Icons.Material.Filled.Add"
                OnClick="CreateWorld">
                Create Your First World
            </MudButton>
        </div>
    }
    else if (TreeState.IsSearchActive && !HasVisibleNodes())
    {
        <div class="article-tree__empty">
            <div class="article-tree__empty-icon">üîç</div>
            <MudText Typo="Typo.body2" Class="mt-2">
                No articles match "@TreeState.SearchQuery"
            </MudText>
        </div>
    }
    else
    {
        <div class="article-tree__nodes">
            @* Dashboard link *@
            <MudNavLink Href="/dashboard" 
                    Match="NavLinkMatch.All"
                    Class="article-tree__dashboard-link">
                <div style="width: 30px;"></div>
                <MudIcon Icon="@Icons.Material.Filled.Home"
                            Color="Color.Primary" 
                            Size="Size.Small" 
                            Style="margin-right: 8px;" />
                <span style="vertical-align: top;">Dashboard</span>
            </MudNavLink>
            
            <MudDivider Class="my-2" Style="opacity: 0.3;" />
            
            @* Worlds and their contents *@
            @foreach (var node in TreeState.RootNodes.Where(n => n.IsVisible))
            {
                <ArticleTreeNode 
                    Node="node"
                    OnSelect="HandleSelect"
                    OnToggle="HandleToggle"
                    OnAddChild="HandleAddChild"
                    OnDelete="HandleDelete"
                    OnMove="HandleMove"
                    DraggedNodeId="_draggedNodeId"
                    DraggedNodeIdChanged="OnDraggedNodeIdChanged" />
            }
            
            <MudDivider Class="my-2" Style="opacity: 0.3;" />
            
            @* Drop zone to make items root-level *@
            @if (_draggedNodeId.HasValue)
            {
                <div class="article-tree__root-drop-zone @(_isOverRootZone ? "article-tree__root-drop-zone--active" : "")"
                     @ondragover="HandleRootDragOver"
                     @ondragover:preventDefault="true"
                     @ondragleave="HandleRootDragLeave"
                     @ondrop="HandleRootDrop"
                     @ondrop:preventDefault="true">
                    <MudIcon Icon="@Icons.Material.Filled.ArrowUpward" Size="Size.Small" Class="mr-2" />
                    <span>Move to root level</span>
                </div>
            }
        </div>
    }
</div>

@code {
    private Guid? _draggedNodeId;
    private bool _isOverRootZone;
    
    protected override async Task OnInitializedAsync()
    {
        TreeState.OnStateChanged += OnTreeStateChanged;
        
        // Initialize tree if not already loaded
        if (!TreeState.RootNodes.Any() && !TreeState.IsLoading)
        {
            await TreeState.InitializeAsync();
        }
    }
    
    private void OnTreeStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }
    
    private bool HasVisibleNodes()
    {
        return TreeState.RootNodes.Any(n => n.IsVisible);
    }
    
    private async Task HandleSelect(Guid nodeId)
    {
        // Get the node to determine its type
        var node = TreeState.RootNodes
            .SelectMany(GetAllNodes)
            .FirstOrDefault(n => n.Id == nodeId);
        
        if (node == null) return;
        
        // Route based on node type
        switch (node.NodeType)
        {
            case TreeNodeType.World:
                Navigation.NavigateTo($"/world/{nodeId}");
                break;
                
            case TreeNodeType.Campaign:
                Navigation.NavigateTo($"/campaign/{nodeId}");
                break;
                
            case TreeNodeType.Arc:
                Navigation.NavigateTo($"/arc/{nodeId}");
                break;
                
            case TreeNodeType.VirtualGroup:
                // Virtual groups just expand/collapse, don't navigate
                TreeState.ToggleNode(nodeId);
                break;
                
            case TreeNodeType.Article:
                TreeState.ExpandPathToAndSelect(nodeId);
                var article = await ArticleApi.GetArticleDetailAsync(nodeId);
                if (article != null && article.Breadcrumbs.Any())
                {
                    var path = string.Join("/", article.Breadcrumbs.Select(b => b.Slug));
                    Navigation.NavigateTo($"/article/{path}");
                }
                break;
        }
    }
    
    // Helper to flatten tree for searching
    private IEnumerable<TreeNode> GetAllNodes(TreeNode node)
    {
        yield return node;
        foreach (var child in node.Children)
        {
            foreach (var descendant in GetAllNodes(child))
            {
                yield return descendant;
            }
        }
    }
    
    private void HandleToggle(Guid nodeId)
    {
        TreeState.ToggleNode(nodeId);
    }
    
    private async Task HandleAddChild(Guid parentId)
    {
        var newId = await TreeState.CreateChildArticleAsync(parentId);
        
        if (newId.HasValue)
        {
            Snackbar.Add("Article created", Severity.Success);
            
            // Navigate to the new article
            var article = await ArticleApi.GetArticleDetailAsync(newId.Value);
            if (article != null && article.Breadcrumbs.Any())
            {
                var path = string.Join("/", article.Breadcrumbs.Select(b => b.Slug));
                Navigation.NavigateTo($"/article/{path}");
            }
        }
        else
        {
            Snackbar.Add("Failed to create article", Severity.Error);
        }
    }
    
    private async Task HandleDelete(Guid nodeId)
    {
        // Get node info for confirmation message
        var article = await ArticleApi.GetArticleDetailAsync(nodeId);
        if (article == null) return;
        
        var title = string.IsNullOrWhiteSpace(article.Title) ? "(Untitled)" : article.Title;
        var message = $"Are you sure you want to delete '{title}'?";
        
        if (article.ChildCount > 0)
        {
            var childText = article.ChildCount == 1 ? "1 child article" : $"{article.ChildCount} child articles";
            message += $"\n\n‚ö†Ô∏è WARNING: This will also delete {childText} and all their descendants.";
        }
        
        message += "\n\nThis action cannot be undone.";
        
        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", message);
        if (!confirmed) return;
        
        var success = await TreeState.DeleteArticleAsync(nodeId);
        
        if (success)
        {
            Snackbar.Add("Article deleted", Severity.Success);
            
            // Navigate to parent or dashboard
            if (article.ParentId.HasValue)
            {
                var parent = await ArticleApi.GetArticleDetailAsync(article.ParentId.Value);
                if (parent != null && parent.Breadcrumbs.Any())
                {
                    var path = string.Join("/", parent.Breadcrumbs.Select(b => b.Slug));
                    Navigation.NavigateTo($"/article/{path}");
                }
            }
            else
            {
                Navigation.NavigateTo("/dashboard");
            }
        }
        else
        {
            Snackbar.Add("Failed to delete article", Severity.Error);
        }
    }
    
    private async Task CreateWorld()
    {
        var dialog = await DialogService.ShowAsync<CreateWorldDialog>("New World");
        var result = await dialog.Result;

        if (result != null && !result.Canceled && result.Data is WorldDto world)
        {
            await TreeState.RefreshAsync();
            Navigation.NavigateTo($"/world/{world.Id}");
            Snackbar.Add("World created", Severity.Success);
        }
    }
    
    // ============================================
    // Drag and Drop
    // ============================================
    
    private void OnDraggedNodeIdChanged(Guid? nodeId)
    {
        _draggedNodeId = nodeId;
        _isOverRootZone = false;
        StateHasChanged();
    }
    
    private async Task HandleMove((Guid ArticleId, Guid? NewParentId) moveInfo)
    {
        var success = await TreeState.MoveArticleAsync(moveInfo.ArticleId, moveInfo.NewParentId);
        
        if (success)
        {
            Snackbar.Add("Article moved", Severity.Success);
        }
        else
        {
            Snackbar.Add("Cannot move article here", Severity.Warning);
        }
        
        _draggedNodeId = null;
    }
    
    private void HandleRootDragOver(DragEventArgs e)
    {
        _isOverRootZone = true;
    }
    
    private void HandleRootDragLeave(DragEventArgs e)
    {
        _isOverRootZone = false;
    }
    
    private async Task HandleRootDrop(DragEventArgs e)
    {
        _isOverRootZone = false;
        
        if (_draggedNodeId.HasValue)
        {
            await HandleMove((_draggedNodeId.Value, null));
        }
    }
    
    public void Dispose()
    {
        TreeState.OnStateChanged -= OnTreeStateChanged;
    }
}
