@inject ITreeStateService TreeState
@inject IArticleApiService ArticleApi
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="chronicis-nav-menu">
    @if (_isLoading)
    {
        <div class="pa-4">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
            <MudText Typo="Typo.body2" Class="ml-2" Style="display: inline;">
                Loading articles...
            </MudText>
        </div>
    }
    else if (_rootArticles == null || !_rootArticles.Any())
    {
        <div class="pa-4 text-center">
            <div style="opacity: 0.5; font-size: 3rem;">ðŸ“š</div>
            <MudText Typo="Typo.body2" Color="Color.Default" Class="mt-2 mb-3">
                No articles yet
            </MudText>
            <MudButton 
                Variant="Variant.Text" 
                Color="Color.Primary"
                Size="Size.Small"
                StartIcon="@Icons.Material.Filled.Add"
                OnClick="CreateRootArticle">
                Create First Article
            </MudButton>
        </div>
    }
    else
    {
        <MudNavMenu Class="chronicis-nav-menu-items">
            @foreach (var article in _rootArticles)
            {
                @RenderArticleNavItem(article)
            }
        </MudNavMenu>
    }
</div>

@code {
    private RenderFragment RenderArticleNavItem(ArticleTreeNode node) => __builder =>
{
    <div class="chronicis-nav-item-container" 
         @onmouseenter="@(() => node.IsHovered = true)"
         @onmouseleave="@(() => node.IsHovered = false)">
        
        <MudNavLink 
            OnClick="@(() => SelectArticle(node))"
            Class="@GetNavItemClass(node)">
            
            <div class="d-flex align-center justify-space-between" style="width: 100%;">
                <div class="d-flex align-center">
                    <!-- Custom expand arrow for parent nodes -->
                    @if (node.HasChildren)
                    {
                        <MudIconButton 
                            Icon="@(node.IsExpanded ? Icons.Material.Filled.ExpandMore : Icons.Material.Filled.ChevronRight)"
                            Size="Size.Small"
                            OnClick="@(async (e) => await ToggleExpand(node))"
                            Style="margin-right: 4px;" />
                    }
                    <MudIcon Icon="@GetNodeIcon(node)"
                             IconColor="Color.Primary"
                        Size="Size.Small" 
                        Class="chronicis-nav-item-icon"                         
                        Style="margin-right: 8px;" />
                    <span>@node.Title</span>
                </div>
                
                <!-- Context menu (three dots) -->
                @if (node.IsHovered)
                {
                    <MudMenu 
                        AnchorOrigin="Origin.BottomRight"
                        TransformOrigin="Origin.TopRight"
                        Dense="true">
                        <ActivatorContent>
                            <MudIconButton 
                                Icon="@Icons.Material.Filled.MoreVert" 
                                Size="Size.Small"
                                Class="chronicis-nav-item-menu"
                                @onclick:stopPropagation="true" />
                        </ActivatorContent>
                        <ChildContent>
                            <MudMenuItem 
                                Icon="@Icons.Material.Filled.Add"
                                OnClick="@(() => CreateChildArticle(node))">
                                Add Child
                            </MudMenuItem>
                            <MudMenuItem 
                                Icon="@Icons.Material.Filled.Delete"
                                OnClick="@(() => DeleteArticle(node))">
                                Delete
                            </MudMenuItem>
                        </ChildContent>
                    </MudMenu>
                }
            </div>
        </MudNavLink>
        
        <!-- Render children if expanded -->
        @if (node.HasChildren && node.IsExpanded && node.Children != null)
        {
            <div class="chronicis-nav-children" style="margin-left: 20px;">
                @foreach (var child in node.Children)
                {
                    @RenderArticleNavItem(child)
                }
            </div>
        }
    </div>
};
}

@code {
    private List<ArticleTreeNode>? _rootArticles;
    private ArticleTreeNode? _selectedNode;
    private bool _isLoading = true;

    protected override async Task OnInitializedAsync()
    {
        await LoadRootArticles();
        TreeState.OnRefreshRequested += OnRefreshRequested;
    }

    private async Task LoadRootArticles()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            var articles = await ArticleApi.GetRootArticlesAsync();
            _rootArticles = articles.Select(a => new ArticleTreeNode(a)).ToList();

            foreach (var article in _rootArticles)
            {
                Console.WriteLine($"Article: {article.Title}, HasChildren: {article.HasChildren}, ChildCount: {article.Article.ChildCount}");
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load articles: {ex.Message}", Severity.Error);
            _rootArticles = new List<ArticleTreeNode>();
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task ToggleExpand(ArticleTreeNode node)
{
    node.IsExpanded = !node.IsExpanded;
    
    if (node.IsExpanded && (node.Children == null || !node.Children.Any()))
    {
        await LoadChildrenForNode(node);
    }
    
    StateHasChanged();
}

    private async void OnRefreshRequested()
    {
        await InvokeAsync(async () =>
        {
            await LoadRootArticles();
            StateHasChanged();
        });
    }

    private void SelectArticle(ArticleTreeNode node)
    {
        _selectedNode = node;
        TreeState.SelectArticle(node.Article.Id);
        StateHasChanged();
    }

    private string GetNavItemClass(ArticleTreeNode node)
    {
        return _selectedNode?.Article.Id == node.Article.Id 
            ? "chronicis-nav-item-selected" 
            : "chronicis-nav-item";
    }

    private string GetNodeIcon(ArticleTreeNode node)
    {
        if (!string.IsNullOrEmpty(node.IconEmoji))
        {
            return node.IconEmoji;
        }
        
        return node.HasChildren 
            ? Icons.Material.Filled.Folder 
            : Icons.Material.Filled.Description;
    }

    private async Task OnExpandedChanged(ArticleTreeNode node, bool expanded)
    {
        node.IsExpanded = expanded;
        
        if (expanded && (node.Children == null || !node.Children.Any()))
        {
            await LoadChildrenForNode(node);
        }
        
        StateHasChanged();
    }

    private async Task CreateRootArticle()
    {
        try
        {
            var createDto = new ArticleCreateDto  // Changed
            {
                Title = "Untitled",
                Body = string.Empty,
                ParentId = null,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);
            await LoadRootArticles();
            // Remove TreeState.SelectArticle(created) - wrong type
            Snackbar.Add("Article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create article: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateChildArticle(ArticleTreeNode parent)
    {
        try
        {
            var createDto = new ArticleCreateDto  // Changed
            {
                Title = "Untitled",
                Body = string.Empty,
                ParentId = parent.Article.Id,
                EffectiveDate = DateTime.Now
            };

            var created = await ArticleApi.CreateArticleAsync(createDto);

            // Expand parent and refresh
            parent.IsExpanded = true;
            await LoadChildrenForNode(parent);
            // Remove TreeState.SelectArticle(created) - wrong type

            Snackbar.Add("Child article created", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create child article: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadChildrenForNode(ArticleTreeNode node)
    {
        try
        {
            var children = await ArticleApi.GetChildrenAsync(node.Article.Id);
            node.Children = children.Select(c => new ArticleTreeNode(c)).ToList();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load children: {ex.Message}", Severity.Warning);
        }
    }

    private async Task DeleteArticle(ArticleTreeNode node)
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>(
            "confirm",
            $"Are you sure you want to delete '{node.Title}'? This action cannot be undone."
        );

        if (!confirmed) return;

        try
        {
            await ArticleApi.DeleteArticleAsync(node.Article.Id);
            await LoadRootArticles();
            Snackbar.Add("Article deleted", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    public void Dispose()
    {
        TreeState.OnRefreshRequested -= OnRefreshRequested;
    }

    // Helper class for tree nodes
    private class ArticleTreeNode
    {
        public ArticleDto Article { get; set; }
        public string Title => Article.Title ?? "New Article";
        public string? IconEmoji => Article.IconEmoji;
        public bool HasChildren { get; set; }
        public bool IsExpanded { get; set; }
        public bool IsHovered { get; set; }
        public List<ArticleTreeNode>? Children { get; set; }

        // Constructor for ArticleDto (from GetRootArticlesAsync)
        public ArticleTreeNode(ArticleDto article)
        {
            Article = article;
            HasChildren = article.ChildCount > 0;
        }

        // Constructor for ArticleTreeDto (from GetChildrenAsync)
        public ArticleTreeNode(ArticleTreeDto treeDto)
        {
            // Convert ArticleTreeDto to ArticleDto
            Article = new ArticleDto
            {
                Id = treeDto.Id,
                Title = treeDto.Title,
                ParentId = treeDto.ParentId,
                HasChildren = treeDto.HasChildren,
                ChildCount = treeDto.ChildCount,
                CreatedDate = treeDto.CreatedDate,
                EffectiveDate = treeDto.EffectiveDate,
                IconEmoji = treeDto.IconEmoji,
                Body = string.Empty  // TreeDto doesn't have body
            };
            HasChildren = treeDto.ChildCount > 0;
        }
    }
}
