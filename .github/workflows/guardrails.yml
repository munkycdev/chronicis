name: Guardrails

on:
  push:
    branches: [ main ]

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: pages
  cancel-in-progress: true

env:
  SOLUTION_PATH: ./Chronicis.CI.sln
  REPORT_DIR_REL: coveragereport

jobs:
  guardrails:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (main)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "9.0.x"

      - name: Show .NET info
        shell: pwsh
        run: |
          dotnet --info
          dotnet --version

      - name: Restore
        shell: pwsh
        run: dotnet restore "${{ env.SOLUTION_PATH }}"

      - name: Build (Release)
        shell: pwsh
        run: dotnet build "${{ env.SOLUTION_PATH }}" --configuration Release --no-restore

      # ------------------------------------------------------------
      # Coverage collection using coverlet.collector (XPlat Code Coverage)
      #
      # Key difference from coverlet.msbuild: the collector approach works
      # at test runtime, not build time. This means --no-build is safe and
      # instrumentation of referenced assemblies works correctly via the
      # Include filter in coverlet.runsettings.
      # ------------------------------------------------------------
      - name: Test with coverage (XPlat Code Coverage)
        shell: pwsh
        run: |
          $workspace = $env:GITHUB_WORKSPACE
          $resultsDir = Join-Path $workspace "TestResults"

          # Clean previous results
          if (Test-Path $resultsDir) { Remove-Item -Recurse -Force $resultsDir }

          dotnet test "${{ env.SOLUTION_PATH }}" `
            --configuration Release `
            --no-build `
            --verbosity normal `
            --collect:"XPlat Code Coverage" `
            --settings coverlet.runsettings `
            --results-directory "$resultsDir"

          # Find all coverage files produced by the collector
          $coberturaFiles = Get-ChildItem -Recurse -Path $resultsDir -Filter "coverage.cobertura.xml" -ErrorAction SilentlyContinue
          if (-not $coberturaFiles -or $coberturaFiles.Count -eq 0) {
            Write-Host "No coverage.cobertura.xml files found under: $resultsDir"
            if (Test-Path $resultsDir) {
              Get-ChildItem -Recurse $resultsDir | Select-Object -First 300 | ForEach-Object { Write-Host $_.FullName }
            }
            throw "Coverage collection produced zero cobertura files."
          }

          Write-Host "Coverage files found ($($coberturaFiles.Count)):"
          $coberturaFiles | Sort-Object FullName | ForEach-Object { Write-Host "  $($_.FullName)" }

      - name: Install ReportGenerator
        shell: pwsh
        run: dotnet tool update -g dotnet-reportgenerator-globaltool

      - name: Generate merged coverage report
        shell: pwsh
        run: |
          $workspace = $env:GITHUB_WORKSPACE
          $resultsDir = Join-Path $workspace "TestResults"
          $reportDir  = Join-Path $workspace "${{ env.REPORT_DIR_REL }}"

          if (Test-Path $reportDir) { Remove-Item -Recurse -Force $reportDir }
          New-Item -ItemType Directory -Force -Path $reportDir | Out-Null

          # Collect all cobertura files and build a sorted, semicolon-separated list
          $reports = Get-ChildItem -Recurse -Path $resultsDir -Filter "coverage.cobertura.xml" `
            | Sort-Object FullName `
            | Select-Object -ExpandProperty FullName

          if (-not $reports -or $reports.Count -eq 0) {
            throw "No cobertura files to merge."
          }

          $reportArg = ($reports -join ';')

          Write-Host "ReportGenerator inputs ($($reports.Count) files):"
          $reports | ForEach-Object { Write-Host "  $_" }

          reportgenerator `
            -reports:"$reportArg" `
            -targetdir:"$reportDir" `
            -reporttypes:"Html;Cobertura;MarkdownSummaryGithub"

          Write-Host "Report generated. Contents:"
          Get-ChildItem $reportDir | ForEach-Object { Write-Host "  $($_.FullName)" }

      - name: Publish coverage summary to GitHub Actions
        shell: pwsh
        run: |
          $summary = Join-Path $env:GITHUB_WORKSPACE "${{ env.REPORT_DIR_REL }}/SummaryGithub.md"
          if (Test-Path $summary) {
            Get-Content $summary | Add-Content $env:GITHUB_STEP_SUMMARY
          } else {
            "Coverage summary not found." | Add-Content $env:GITHUB_STEP_SUMMARY
          }

      - name: Compute overall coverage rates
        id: rates
        shell: pwsh
        run: |
          $reportDir = Join-Path $env:GITHUB_WORKSPACE "${{ env.REPORT_DIR_REL }}"
          $merged = Join-Path $reportDir "Cobertura.xml"

          if (-not (Test-Path $merged)) {
            $found = Get-ChildItem -Path $reportDir -Filter *Cobertura*.xml -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) { $merged = $found.FullName }
          }

          if (-not (Test-Path $merged)) {
            throw "Merged Cobertura.xml not found."
          }

          Write-Host "Using merged Cobertura file: $merged"
          python3 ci/coverage/extract_rates.py $merged | Out-File -Encoding utf8 rates.json

          $rates = Get-Content rates.json | ConvertFrom-Json
          "linePct=$($rates.linePct)"     | Out-File -Append -Encoding utf8 $env:GITHUB_OUTPUT
          "branchPct=$($rates.branchPct)" | Out-File -Append -Encoding utf8 $env:GITHUB_OUTPUT

      # ------------------------------------------------------------
      # Update coverage history branch
      # ------------------------------------------------------------
      - name: Checkout coverage history branch
        uses: actions/checkout@v4
        with:
          ref: coverage-history
          path: _history
          fetch-depth: 1

      - name: Update history.json (via script)
        id: history
        shell: pwsh
        env:
          LINE_PCT: ${{ steps.rates.outputs.linePct }}
          BRANCH_PCT: ${{ steps.rates.outputs.branchPct }}
          SHA: ${{ github.sha }}
          HISTORY_PATH: _history/history.json
        run: |
          $iso = python3 ci/coverage/update_history.py
          "ISO_DATE=$iso" | Out-File -Append -Encoding utf8 $env:GITHUB_ENV

      - name: Commit updated history.json
        shell: pwsh
        working-directory: _history
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add history.json
          git diff --cached --quiet
          if ($LASTEXITCODE -eq 0) {
            Write-Host "No history changes to commit."
            exit 0
          }

          git commit -m "Update coverage history: $env:ISO_DATE"
          git push origin HEAD:coverage-history

      # ------------------------------------------------------------
      # Assemble Pages site and publish
      # ------------------------------------------------------------
      - name: Assemble Pages site
        shell: pwsh
        run: |
          $workspace = $env:GITHUB_WORKSPACE
          $site = Join-Path $workspace "site"

          if (Test-Path $site) { Remove-Item -Recurse -Force $site }
          New-Item -ItemType Directory -Force -Path (Join-Path $site "coverage/report") | Out-Null

          Copy-Item -Recurse -Force "ci/pages/*" $site
          Copy-Item -Recurse -Force "${{ env.REPORT_DIR_REL }}/*" (Join-Path $site "coverage/report/")
          Copy-Item -Force "_history/history.json" (Join-Path $site "coverage/history.json")
          "OK" | Out-File -Encoding utf8 (Join-Path $site "health.txt")

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: site

  deploy-pages:
    needs: guardrails
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
